<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style1.css">
    <title>文章-1</title>
</head>
<body>
  <div id="zz"></div>
  <div id="kaip"></div>
  <div id="kaip2"></div>

    <img src="..\TP\bj.png" class="img">
    <div class="bjx"></div>
    <div id="bttm"></div>
    
    <div id="xia"><p style="color: white;" id="xia2">向下滑动进入主页</p><img src="TP\xia.png"></div>
    <div class="bs">
        <nav id="dhyd">
            <a href="#">HOME</a>
            <a href="#">CS</a>
            <a href="#">CS</a>
            <a href="#">CS</a>
            <a href="#">CS</a>
            <a href="#">CS</a>
        </nav>
    </div>
      <div class="DLW-zy"></div>
      <div class="DLW"><a href="..\index.html">DLW_starry</a></div>
        
    <div>
        <div class="bt-1">
            <h1>JS+CSS元素进入屏幕触发动画</h1>
        </div>
        
    <div class="zybj">
        <div class="wzxz">
            <p>
                .jzbox{<br>
                    opacity: 0;<br>
                    filter: blur(5px);<br>
                    transition: all 1s;<br>
                    transform: translateX(-40%);<br>
                }
                <br>
                .active {<br>
                    opacity: 1;<br>
                    filter: blur(0);<br>
                    transform: translateX(0);<br>
                }<br>
                <br>
                .jzbox2{<br>
                    opacity: 0;<br>
                    filter: blur(5px);<br>
                    transition: all 1s;<br>
                    transform: translateX(10%);<br>
                }<br>
                .active2{<br>
                    opacity: 1;<br>
                    filter: blur(0);<br>
                    transform: translateX(0);<br>
                }<br>
                <br>
                const observer = new IntersectionObserver((entries) => {<br>
                  entries.forEach((entry) => {<br>
                    if (entry.isIntersecting) {<br>
                      entry.target.classList.add("active");<br>
                      entry.target.classList.add("active2");<br>
                    } else {<br>
                      entry.target.classList.remove("active");<br>
                      entry.target.classList.remove("active2");<br>
                    }<br>
                  });<br>
                });<br>
                <br>
                const hiddenElements1 = document.querySelectorAll(".jzbox");<br>
                hiddenElements1.forEach((el) => observer.observe(el));<br>
                <br>
                const hiddenElements2 = document.querySelectorAll(".jzbox2");<br>
                hiddenElements2.forEach((el) => observer.observe(el));<br>
                <br>
                <br>
                这段代码使用了Intersection Observer API来观察页面上的元素，当这些元素进入或离开视口时，会触发相应的回调函数。具体来说，这段代码的作用是当.jzbox和.jzbox2类元素进入视口时，给它们添加active和active2类，当它们离开视口时，移除这些类。<br>
                实现原理<br>
                <br>
                1. 创建Intersection Observer实例：<br>
                const observer = new IntersectionObserver((entries) => {<br>
                这里创建了一个Intersection Observer实例，并传入一个回调函数。这个回调函数会在被观察的元素进入或离开视口时被调用。<br>
                <br>
                1. 观察特定元素：<br>
                const hiddenElements1 = document.querySelectorAll(".jzbox");<br>
                hiddenElements1.forEach((el) => observer.observe(el));<br>
                const hiddenElements2 = document.querySelectorAll(".jzbox2");<br>
                hiddenElements2.forEach((el) => observer.observe(el));<br>
                使用document.querySelectorAll选择所有具有.jzbox和.jzbox2类的元素，并使用observer.observe(el)方法开始观察这些元素。<br><br>
                entries.forEach((entry) => {<br>
                    if (entry.isIntersecting) {<br>
                        entry.target.classList.add("active");<br>
                        entry.target.classList.add("active2");<br>
                    } else {<br>
                        entry.target.classList.remove("active");<br>
                        entry.target.classList.remove("active2");<br>
                    }<br>
                });<br>
                <br>
                <br>
                当被观察的元素进入或离开视口时，回调函数会被触发。entries是一个包含所有被观察元素的数组。对于每个元素，如果entry.isIntersecting为true，则表示该元素已经进入视口，此时给该元素添加active和active2类；如果为false，则表示该元素已经离开视口，此时移除这些类。<br>
                用途<br>
                这种技术常用于实现懒加载、无限滚动、视口内的动画效果等场景。通过观察元素是否进入视口，可以动态地添加或移除CSS类，从而实现各种交互效果。<br>
                注意事项<br>
                <br>
                <br>
                1. 兼容性：Intersection Observer API在较新的浏览器中才被支持，对于旧浏览器可能需要polyfill。<br>
                2. 性能：频繁地观察大量元素可能会影响页面性能，建议根据实际需求合理选择观察的元素。<br>
                3. 配置选项：Intersection Observer API提供了丰富的配置选项，如root、rootMargin、threshold等，可以根据具体需求进行调整。<br>
            </p>
        </div>
    </div>

    <script>


// 触碰元素时跳转网页，但是增加需求时js代码必须增加
document.querySelector('.tzwy-x1').addEventListener('click', function() {
    window.location.href = 'WZ/wz1.html'; // 替换为你想要跳转的网址
});
document.querySelector('.home').addEventListener('click', function() {
    window.location.href = 'https://space.bilibili.com/593933246'; // 替换为你想要跳转的网址
});
    </script>
    
</body>
</html>