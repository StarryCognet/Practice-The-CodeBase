 一、HTML+CSS

### 1、移动端适配你是如何做的？

```
移动端适配:rem/em ,vh,vw,%,@media,viewport
我在上家公司主要使用rem、vh、vw、百分比作单位，使用flex进行布局、利用viewport进行适配
，以iphone6机型为基准适配其他机型 ，对具有刘海屏的手机做特殊处理。当然还有其他的适配方案。
```



### 2、如何让一个盒子上下左右都居中

```

1、绝对定位、左50%、上50%、margin-left：盒子宽的一半的负值、margin-top：盒子高的一半的负值
2、绝对定位、上下左右为0、margin：0 auto
3、使用弹性盒实现、使用display：flex、justify-content：center、align-items: center
4、使用定位及变形、给元素绝对定位左50%、上50%、transform：translate（-50% ，-50%）
```

### 3、说说你的盒模型的理解

```
在HTML中，可以把元素看做盒子，每个盒子包括：实际内容（content）、内边距（padding）、边框（border）、外边距（margin），
1、标准盒模型（W3C标准盒模型）
标准盒模型（W3C盒子模型），即盒子模型的width（height）=实际content的宽高+padding+border

2、怪异盒模型（IE盒模型）
怪异盒模型（IE盒子模型），其盒模型的width（height）= 设置的width（height）

3、盒模型转换
通过 box-sizing 属性来切换：
box—sizing: content-box; 是默认值，盒子以标准盒模型特性来渲染；
box-sizing: border-box; 盒子以怪异盒模型特性来渲染。
```

### 4、flex的常用属性

```
父元素添加的属性有：
	display-flex		设置元素为弹性盒
	justify-content  	控制子元素主轴排列方式
	align-items 		控制子元素侧轴的排列方式
	align-content  		控制多轴的排列方式
	flex-wrap			是否换行
	flex-direction  	排列方式（行（row）、列（column））
	flex-flow			是flex-direction 和 flex-wrap 属性的复合属性，默认值是row nowrap 
	
子元素添加的属性有：
	order：		定义元素的排列顺序，数值越小排列越靠前，默认为0.
	flex-grow：	定义元素在剩余空间如何放大，默认为0，即有剩余空间也不放大。
	flex-shrink：定义元素的缩小比例，默认为1，即如果空间不足，该元素将缩小。
	align-self：	设置子元素在纵轴的排列方式  可以覆盖父容器的align-items的设置。
	flex-basis：	定义在分配多余空间之前，元素占据主轴的空间。
	flex：		是flex-grow、flex-shrink、flex-basis的符合属性，默认值为0 1 auto。
	
	flex:1 ==> flex:1 1 auto
	
     详细讲解： https://blog.csdn.net/weixin_43554584/article/details/113839778

```

### 5、遇到过浏览器兼容性问题

首先我分为三部分 ：HTML，css，javascript

html

```
对于html兼容
		主要就是低版本浏览器不识别新增的语义化标签（header、footer、nav、section、article），我们可以在script标签内先进行创建标签，然后再使用，也可以使用js插件。
```

css

```、
低版本的浏览器不支持
1、不同浏览器的margin和padding的差异较大。
   解决方法：在css里使用：*{margin:0px; padding:0px}。
2、ie9以下不支持半透明属性 opacity
   opacity：0.5
   解决使用filter属性
3、flex ie10以下不支持
4、img图片有间隔
   解决：把img 变成块级元素    display: block;
5、光标显示不一样
   cursor：hand
   解决方案：统一使用cursor：pointer
   cursor: url()   图片光标，IE11以下浏览器不支持
6、IE无法设置滚动条样式

7、css3的新特性 低版本IE11不支持

```

javascript

```
Js方面的兼容问题：
		一般需要自己封装一个方法（函数），实现浏览器兼容性处理
		1、获取浏览器窗口大小
		
		2、Event对象 参数问题  绑定事件方式
		 事件对象：e ? e : window.event;
		
		3、阻止默认行为、阻止冒泡
		 window.event.cancelBubble = true; //ie
		  e.stopPropagation(); //非ie
		
		这些都需要有兼容性写法，，，，，，，，
```

### 6、浮动问题你是怎么解决的?

浮动带来的主要问题

1. **父元素高度塌陷**：浮动元素脱离文档流，导致父元素无法自动计算高度
2. **布局混乱**：后续非浮动元素可能会环绕浮动元素，而非从下方开始
3. **边距重叠异常**：浮动元素的边距行为与常规流中的元素不同
4. **响应式布局困难**：浮动布局在不同屏幕尺寸下可能表现不一致

```
1、父元素设置高度
2、给父元使用overflow：hidden
3、在父元素内多写一个元素，使用行内样式写入style=“clear：both”；
4、使用万能清除浮动法
	.clearfixed::after{
		content:””;
		clear:both;
		height:0;
		display:block;
		overflow:hidden
	}
5、使用flex布局

```

### 7、移动端适配meta标签(viewport)有哪些属性

| width         | 设置layout viewport  的宽度，为一个正整数，或字符串"width-device" |
| ------------- | ------------------------------------------------------------ |
| initial-scale | 设置页面的初始缩放值，为一个数字，可以带小数                 |
| minimum-scale | 允许用户的最小缩放值，为一个数字，可以带小数                 |
| maximum-scale | 允许用户的最大缩放值，为一个数字，可以带小数                 |
| user-scalable | 是否允许用户进行缩放，值为"no"或"yes", no 代表不允许，yes代表允许 |
|               | 1                                                            |

### 8、position定位有那些属性及区别是什么

```
一共有五个分别是： relative相对定位、absolute绝对定位、fixed固定定位、static（四大体可）默认值、inherit（音嗨瑞特）。
常用的有三个：relative、absolute、fixed
特点：
	Relative相对定位：元素本身位置会被保留，是根据自身位置进行偏移
	Absolute绝对定位：元素本身位置不被保留，根据离他最近的具有定位属性的父元素进行偏移，如果父级没有定位，那么会根据根元素进行偏移。
	Fixed固定定位：元素本身位置不被保留，根据浏览器窗口进行偏移。
	static  默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。
 	inherit 规定从父元素继承 position 属性的值。
 	
 	
 	css3新增了 position:sticky 粘性定位

```

### 9、IOS端是如何适配的

```
IOS端的适配
	1、分析机型:整体上把现有的iOS屏幕分为两大类，非全面屏和全面屏
		非全面屏：（6、6s、7、8）和Plus系列（6 Plus、6s Plus、7 Plus、8 Plus)
		全面屏： iPhoneX  iPhoneXR  iPhone 11，12，13，14 等 
		屏幕尺寸总结，iPhone在逻辑像素共有四种，375x667，375x812，414x736，414x896
	2、安全区域
		非全面屏都是矩形，整个屏幕都是安全区域。
		全面屏受到大圆角、刘海以及底部的影响，UI图更需要考虑安全区域
		顶部44pt、 底部34pt	
	3、以iphone6为进行制作去适配其它机型，对iphoneX单独处理

```

### 10、了解2X图和3X图吗

```
 因为手机的dpr有2.0和3.0的，所以设计师会切出2X和3X图，我们制作的时候可以根据dpr的不同引入不同的图片
使用的是media(媒体查询)
```

### 11、H5 怎么引用原生代码，和原生怎么引入H5代码

```
通过JSbridge 
```

### 12、HTML5的新特性

```
1. 新增绘画 canvas元素
2. 新增媒介回放 video 和 audio 元素
3. 新增本地离线存储 localStorage 和sessionStorage 
4. 新增语义化标签： header、footer、nav、section、article等
5. 新增表单控件，比如 calendar(日历)、date、time、email、url、search等
```

### 13、CSS3的新特性

```
1、新增了选择器：first-of-type  last-of-type  nth-of-type...    
2、新增的属性：圆角  盒子阴影   文字阴影  盒子大小  RGBA透明度  服务器端字体  边框图片  多栏布局  多背景图  媒体查询  wordwrap  变形  动画,flex布局

```

### 14、如何处理HTML5新标签的浏览器兼容问题？

```
方法一 :
	1、使用静态资源的html5shiv包
    <!--[if lt IE9]>
      <script src="http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js">		</script>
	<![endif]-->
	2、载入后，初始化新标签的css
	header, section, footer, aside, nav, main, article, figure { display: block; }
方法二:
	IE6/IE7/IE8支持通过document方法产生的标签，利用这一特性让这些浏览器支持HTML5新标签

```

### 15、在地址栏输入url之后发生了什么（http请求是如何解析文档的）

```
1.DNS解析，将域名地址解析为ip地址（当输入url回车之后）
	读取浏览器DNS缓存、读取系统DNS缓存、路由器DNS缓存、网络运营商DNS缓存
	递归搜索   blog.baidu.com
			.com域名下查DNS解析
			.baidu域名下查DNS解析
			.blog域名下查DNS解析
				出错了
2.（在跟服务器交互之前）TCP链接  TCP三次握手
		第一次握手：由浏览器发起，告诉服务器我要发送请求了
		第二次握手：由服务器发起，告诉浏览器我准备接收了，你赶紧发送吧。
		第三次握手：由浏览器发送，告诉服务器，我马上就发了。准备接收吧。

3.发送请求
	请求报文，HTTP协议的通信内容
4.接受响应
	响应报文
5.渲染页面
	-遇见HTML标记，浏览器会调用HTML解析器，解析成Token标记（对象上的属性名和属性值）并构成DOM树
	-遇见style/link标记，浏览器调用css解析器，处理css标记并构建cssDOM树
	-遇到script标记，调用javascript解析器，处理script代码（绑定事件，修改dom树/cssdom树）
	-将dom树和cssdom树合并成一个（render）渲染树
	-根据渲染树来计算布局，计算每个节点的几何信息（布局）
    -将各个节点颜色绘制到屏幕上（渲染）

	注意：

		这个5个步骤不一定按照顺序执行，如果dom树或cssdom树被修改了，可能会执行多次布局和渲染，往往实际页面中，这些步骤都会执行多次的。

6.断开链接 TCP的四次挥手
	第一次挥手：由浏览器发起的，发送给服务器，我东西发送完了（请求报文），你准备关闭吧。
	第二次挥手：由服务器发起的，告诉浏览器，我东西接受完了（请求报文），我准备关闭了，你也准备吧。
	第三次挥手：由服务器发起，告诉浏览器，我东西发送完了（响应报文），你准备关闭吧。
	第四次挥手：由浏览器发起，告诉服务器，我东西接受完了（响应报文），我准备关闭了，你也准备吧


重绘和回流
	什么是回流
当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。

什么是重绘
	当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。

区别：
他们的区别很大：
	回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流
	当页面布局和几何属性改变时就需要回流
比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变
```

### 16、说说你对语义化的理解

```
1、去掉或者丢失样式的时候能够让页面呈现出清晰的结构；
2、有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
3、方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
4、便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。
```

### 18、BFC                                                                      

**1、BFC 是什么?**

 BFC (Block Formatting Context)格式化上下文 
指一个独立的渲染区域，或者说是一个隔离的独立容器
可以理解为一个独立的封闭空间。无论如何不会影响到它的外面

**2、形成BFC的条件**

1）绝对定位元素，position(absolute，fixed) 

2）浮动元素，float 除none 以外的值 
3）display为以下其中之一的值inline-block，table-cell，table- caption、flex
4）overflow除了visible以外的值(hidden，auto，scroll)
5）body根元素

**3、BFC的特性**

1）内部的Box会在垂直方向上一个接一个的放置。
2）垂直方向上的距离，margin 会重叠 
3）bfc的区域不会与float的元素区域重叠 
4）计算bfc的高度时，浮动元素也参与计算 
5）bfc就是页面上的一个独立容器。 
6）容器里面的子元素不会影响外面元素

**4、BFC解决什么问题？**

1、解决边距重叠问题

```
  <style>
        .box0{
            /*  设box0为BFC元素 */
            overflow: hidden;
        }
        .box1{
            background: salmon;
            width: 200px;
            height: 100px;
            margin-bottom: 50px;
           
        }
        .box2{
            background: skyblue;
            width: 200px;
            margin-top: 100px;
            height: 100px;
           
        }
    </style>
  <div class="box0">
        <div class="box1"></div>
    </div>
 <div class="box2"></div>
```

2、制作两栏布局

3、清除元素内部的浮动

4、高度塌陷问题

### 19、画0.5px线条

```
  .box{
         height: 1px;
         background:red;
         width: 300px;
         transform: scaleY(0.5)
       }
       
```

### 20、什么是外边距重叠？重叠的结果是什么？

```
【答案解析】外边距重叠就是margin-collapse； 在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式称为折叠，并且因而所结合成的外边距称为折叠外边距。

折叠结果计算规则： 两个相邻的外边距都是正数时，折叠结果是他们两者之间较大的值； 
两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值；
两个外边距一正一负时，折叠结果是两者的相加的和
```

### 21、怎么解决外边距重叠?

```
解决：使用BFC
	 （1）设置padding代替margin
     （2）设置float
     （3）设置overflow
     （4）设置position：absolute 绝对定位
     （5）设置display： inline-block 
```

### 22、使用css画半个像素线条

```
【答案解析】height: 1px; transform: scale(0.5);
```

### 23、隐藏div有几种方式？

```
1: display none (元素消失) 会产生回流
2: visibility hidden (只是单纯的隐藏,元素还是占位置)  
3: position：absolutely；定位 (top给成负值)
4: opacity:0; 透明度设置为0
6: overflow:hidden; 超出隐藏(高度设置为0)
```

### 24、重绘和回流（重排）（哪些情况重绘，哪些回流)

```
重绘: 当页面中元素样式(外观属性)的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等）如：
    
* color			    * background			* outline(轮廓))
* border-style		* background-image		* outline-color
* border-radius		* background-position	* outline-style
* visibility		* background-repeat		* outline-width
* text-decoration	* background-size	    * box-shadow


回流: 元素的尺寸、结构、或某些属性发生改变时，浏览器根据视口重新计算位置和大小

会导致回流的操作：

页面首次渲染
浏览器窗口大小发生改变
元素尺寸或位置发生改变
元素内容变化（文字数量或图片大小等等）
元素字体大小变化
添加或者删除可见的DOM元素
激活CSS伪类（例如：:hover）
查询某些属性或调用某些方法

可能会导致回流的属性或方法：
    * width         * top          * text-align
    * height	    * bottom       * overflow-y
    * padding	    * left         * font-weight
    * margin	    * right        * overflow
    * display       * position     * font-family
    * border-width  * float        * line-height
    * border		* clear        * vertival-align
    * min-height	* white-space


总结: 回流一定引起重绘，但是重绘不一定引起回流

减少重绘和回流的操作：

1、减少table使用：table及其内部元素除外，可能需要多次计算，通常要花3倍于同等元素的时间。
2、避免设置多层内联样式。
3、避免使用CSS表达式（例如：calc()）
4、尽量使用css3的transform来代替对top left等的操作
5、尽量使用css属性简写:如：用boder代替boder-width，boder-style，boder-color

```



### 25、移动端适配1px问题

```
问题: 移动端的1px在有些机型上看上去有些粗，虽然写着1px，但看上去的效果是2px?
答: 使用伪类+transform方法，原理就是把原先的border去掉，然后利用:border或者:after重做border,
	并transform的scale缩小一半，原先的元素相对定位，新做的border绝对定位
```

### 26、居中为什么要使用transform（为什么不使用marginLeft/Top)

```
transform 属于合成属性，不会引起整个页面的回流重绘，节省性能消耗，但是占用内存会大些

margin-top/left属于布局属性，会引起页面layout回流和repaint重绘。
```

### 27、介绍css3中position:sticky

```
粘性定位可以被认为是相对定位(position: relative)和固定定位(position: fixed)的混合。元素在跨越特定阈值前为相对定位，之后为固定定位

1、该元素并不脱离文档流，仍然保留元素原本在文档流中的位置
2、元素固定的相对偏移是相对于它的父标签而言。

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .title {
      background-color: salmon;
      position: sticky;
      top: 0px;
    }
  </style>
</head>

<body>
  <div class="header">网站头部</div>
  <!-- 粘性约束元素 -->
  <div class="article">
    <!-- sticky 元素 -->
    <h2 class="title">彻底理解粘性定位 - position: sticky</h2>
    <div class="content" style="height:1000px">...</div>
  </div>
  <div class="footer">网站底部</div>
</body>

</html>
```

### 28、为什么要初始化css样式？

```
因为浏览器的兼容问题，不同浏览器对有些标签的默认值不同，如果不初始化css，会导致不同浏览器页面间的显示差异。
```

### 29、说说你对语义化的理解？

```
根据内容结构选择适合的标签
1、样式丢失或者去掉样式以后，页面仍然可以呈现出清晰的结构
2、有利于SEO,让爬虫可以抓到更多有效的信息
3、方便其他设备渲染网页（比如:盲人阅读器等）
4、更具可读性，便于团队开发维护
```

### 30、CSS样式覆盖规则

```
!important > 内联样式 > id选择 > （class选择 = 伪类选择） > (标签选择 = 伪元素选择)
```

### 31、box-sizing常用的属性有哪些？分别有什么作用？

```
（1）content-box
宽高是元素本身的宽高 不包含border+padding

（2）border-box
元素的宽高已经包含了border+padding

```

### 32、css的选择器有哪些？哪些属性可以继承？

```
1、id选择器
2、类选择器
3、标签选择器
4、后代选择器
5、子选择器
6、兄弟选择器(所有的兄弟)
7、相邻兄弟选择器
8、属性选择器
9、伪类选择器


css哪些属性可以继承
在CSS中，可以继承的属性包括：

字体系列属性：如font-family、font-weight、font-size、font-style。
文本系列属性：如text-indent、text-align、line-height、word-spacing、letter-spacing、text-transform、color。
元素可见性：如visibility。
列表布局属性：如list-style、list-style-type、list-style-image等。
光标属性：如cursor。

不可继承的属性包括：`display`、`margin`、`border`、`padding`、`background`、`height`、`min-height`、`max-height`、`width`、`min-width`、`max-width`、`overflow`、`position`、`left`、`right`、`top`、`bottom`、`z-index`、`float`、`clear`、`table-layout`、`vertical-align`、`page-break-after`、`page-break-before`和`unicode-bidi`。
```

### 33、解释css sprites ，如何使用?(精灵图)

```
1、什么是精灵图
将一些小图标放在一张图上

2、精灵图的优点
减少图片的总大小
减少下载图片资源请求，减小建立连接的消耗

3、精灵图的使用方式
.icon1 {
    background-image: url(css/img/sidebar.png);
    background-repeat: no-repeat;
    background-position: 20px  20px;
 }
// 第一个数是x轴， 第二个数是y轴
```

### 34、左右固定，中间自适应样式

```
1、使用flex布局
左右两边给固定宽度，中间flex:1

2、使用浮动


    <style>
     
        .body{
            width: 100%;
            height: 100vh;
            background: skyblue;
            position: relative;
        }
        .left{
            background: red;
            width: 100px;
            
            float: left;
            height: 100%;

        }
        .right{
            background: yellow;
            width: 200px;
        float: right;
        height: 100%;
 
        }
        .main{
          
            background: blue;
            height: 100%;
            margin-left: 100px;
            margin-right: 200px;
        }
        
    </style>

    <div class="body">
        <div class="right"></div> 
       <div class="left"></div> 
        <div class="main"></div>
    
    </div>

   

3、定位

<style>
        ul,li{
            list-style: none;
        }
        .body{
            width: 100%;
            height: 100vh;
            background: skyblue;
            /* display: flex; */
            position: relative;
        }
        .left{
            background: red;
            width: 100px;
            position: absolute;
            left: 0;
            top: 0;
            height: 100%; 
         

        }
        .right{
            background: yellow;
            width: 200px;
         position: absolute;
            right: 0;
            top: 0;
            height: 100%;
        }
        .main{
          
            background: blue;
            height: 100%;
            margin-left: 100px;
            margin-right: 200px;
        }
        
    </style>

    <div class="body">
        <div class="right"></div> 
       <div class="left"></div> 
        <div class="main"></div>
    
    </div>

```

### 35、实现一个div在不同分辨率下的水平垂直居中

```
1、使用flex布局
   给元素 display:flex,justify-content: center,align-items: center;
2、使用相对于屏幕定位(position:relative)
   top：50%
   left：50%
```

### 36、上下固定，中间滚动布局如何实现

```
首先 先给上下固定高度，中间也给一个高度，然后给中间一个overflow-y:auto
```

### 37、css实现border渐变

```
1、使用border-image
2、使用 background-image
4、伪元素
```

### 38、纯css实现一个高宽比为1：3的盒子 列举几种方式

```
  <style>
    .box{
      width: 100%;
      height: 100vh;
    }
    .box2{
      width:60%;
      background: red;
      padding-bottom:20%;
      
    }
  </style>
  <div class="box">
    <div class="box2"></div>
  </div>
  
   padding-bottom值为 div宽度的1/3
```

### 39、css实现一个旋转的圆

```
在css中，可以先利用border属性和border-radius属性给一个正方形元素设置成圆环样式，再利用animation属性和@keyframes 规则还有transform属性实现圆环旋转即可

列如： <div></div>
	   div{
           width:200px;
           height:200px;
           border:100px solid black;
           border-top-color:pink;
           border-radius:50%;
           animation:fadenum 5s ;
        }
        @keyframes fadenum{
           100%{transform:rotate(360deg);}
        }
```

### 40、CSS3新增伪类有那些？

```
1、elem:nth-child(n)选中父元素下的第n个子元素，并且在这个子元素的标签名为elem，n可以接受具体的数值，      也可以接受函数。
2、elem:nth-last-child(n)作用同上，不过是从后开始查找。
3、elem:last-child选中最后一个子元素。
4、elem:only-child如果elem是父元素下唯一的子元素，则选中之。
5、elem:nth-of-type(n):查找第n个elem标签的元素。可以为一个函数。
6、elem:first-of-type:选中父元素下第一个elem类型的元素。
7、elem:last-of-type:选中父元素下最后一个elem类型的元素。
8、elem:only-of-type:如果父元素下的子元素只有一个elem类型的元素，则选中该元素。
9、elem:empty:选中不包含子元素和内容的elem类型的元素。
10、elem:target:选中当前活动的elem元素。
11、:not(elem):选择非elem元素的每一个元素。
12、:enabled:控制表单控件的禁用状态。
13、:disabled:控制表单的禁用状态。
14、:checked单选框和复选框被选中。
```

### 41、介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？

```
有两种， IE盒子模型、W3C盒子模型；
盒模型：内容(content)、填充(padding)、边界(margin)、 边框(border)；
区 别：IE的content部分把 border 和 padding计算了进去;
```

### 42、display:inline-block 什么时候不会显示间隙？

```
1、移除空格
2、使用margin负值
3、使用font-size:0
4、letter-spacing
5、word-spacing
```

### 43、行内元素float:left后是否变为块级元素？

```
行内元素设置成浮动之后变得更加像是 inline-block
行内块级元素，设置成这个属性的元素会同时拥有行内和块级的特性，最明显的不同是它的默认宽度不是 100%，行内元素默认 100%宽度占据一行
这时候给行内元素设置 padding-top 和 padding-bottom 或者 width、height 都是有效果的
```

### 44、垂直塌陷及解决方法

```
情况一：浮动元素无法撑开标准流的父元素，导致父元素高度塌陷
        解决方法：
        1.直接给父元素设置该高度
        2.使用额外标签法清除浮动
        3.使用单伪元素清除法
        4.使用双伪元素清除法
        给父元素设置overflow:hidden
情况二：互相嵌套的块级元素，给子元素设置margin-top，父子元素的margin-top会合并，父元素会一起往下移动
        1.给父元素设置border-top
        2.给父元素设置padding-top
        3.设置浮动
        4.转换成行内块元素
        5.给父元素设置overflow:hidden
```

### 45、flex布局

```
flex是Flexible Box的缩写，意为弹性布局，用来为盒模型提供最大的灵活性
采用Flex布局的元素，称为Flex容器(flex container)，简称容器。他是所有子元素自动称为容器成员，称为Flex项目(flex item)简称项目
```

### 46、1rem、1em、1vw、1vh、1px各自代表的含义

```
rem:页面所有的rem单位的长度都是相对于根元素元素的font-size大小,即1rem等于根元素元素的font-size大小。
em:子元素字体大小的em是相对于父元素字体大小 元素的width/height/padding/margin用em的话是相对于该元素的font-size
vh:全称是 Viewport Width 和 Viewport Height，视口的宽度和高度，1vh相当于 视口高度的 1%。
px:相对长度单位。像素px是相对于显示器屏幕分辨率而言的。
```

### 47、rem和em有什么区别

```
【答案解析】两者区别：
em会继承父级元素的字体大小。 em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。 
使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素
```

### 48、iframe的优缺点有哪些？

```
【答案解析】
优点： iframe能够原封不动地把嵌入的网页展示出来； 
提高页面代码的复用性； 
解决加载缓慢的第三方内容，如图标和广告等的加载问题；
在处理上传或局部刷新时，避免了页面整体刷新； 
iframe解决部分跨域问题； 

缺点： iframe会阻塞主页面的 onload 事件； 
无法被一些搜索引擎索引到； 页面会增加服务器的http请求；
会产生很多页面，不便于管理； 很多移动设备无法完全显示框架，设备兼容性差；
会出现区域的上下、左右滚动条，滚动条会挤占页面空间；
使用框架时，要保证正确的使用导航链接，容易造成链接死循环； 随着前端技术的发展，逐渐使用vue、react单页面应用 来代替iframe。

```

### 49、左边固定右边自适应，左右两边固定中间自适应布局怎么实现？

```
【答案解析】经典布局 一、圣杯布局 二、双飞翼布局 三、使用CALC（css3中提供的一个计算公式） 四、flex（若不考虑兼容，首选flex） 五、定位（若考虑兼容，选择定位）

参考：https://blog.csdn.net/xxh20171777/article/details/111589604
```

### 50、常用的几种布局方式，谈谈你对CSS布局的理解

```
【答案解析】固定布局 流式布局（自适应布局） 弹性布局（伸缩布局） 定位布局 浮动布局 响应式布局（媒体查询）
```

### 51、postcss的作用

```
1、可以直观的理解为：它就是一个平台。为什么说它是一个平台呢？因为我们直接用它，感觉不能干什么事情，但是如果让一些插件在它上面跑，那么将会很强大
2、PostCSS 提供了一个解析器，它能够将 CSS 解析成抽象语法树
3、通过在 PostCSS 这个平台上，我们能够开发一些插件，来处理我们的CSS，比如热门的：autoprefixer
4、postcss可以对sass处理过后的css再处理 最常见的就是autoprefixer
```

### 52、stylus/sass/scss/less区别

```
均具有“变量”、”混合“、“嵌套”、”颜色混合“五大基本特性
sass和lass语法较为严谨，less要求一定要使用大括号”{}“，sass和stylus可以通过缩进表示层次和嵌套关系
sass无全局变量的概念，less和stylus有类似其他语言的作用域概念
sass是基于Ruby语言的，而less和stylus可以基于nodeJs NPM 下载相应库后进行编译，这也就是为什么安装sass的时候有时候会报错，需要安装python脚本
```

### 53、base64的原理及优缺点

```
1. 优点
（1）base64格式的图片是文本格式，占用内存小，转换后的大小比例大概为1/3，降低了资源服务器的消耗；
（2）网页中使用base64格式的图片时，不用再请求服务器调用图片资源，减少了服务器访问次数。
2. 缺点
（1）base64格式的文本内容较多，存储在数据库中增大了数据库服务器的压力；
（2）网页加载图片虽然不用访问服务器了，但因为base64格式的内容太多，所以加载网页的速度会降低，可能会影响用户的体验。
（3）base64无法缓存，要缓存只能缓存包含base64的文件，比如js或者css，这比直接缓存图片要差很多，而且一般HTML改动比较频繁，所以等同于得不到缓存效益。
<img src="data:image/jpeg;base64,/9j/4AAQS……"/>
因为base64的使用缺点，所以一般图片小于10kb的时候，我们才会选择使用base64图片，比如一些表情图片，太大的图片转换成base64得不偿失。当然，极端情况极端考虑。
```

### 54、CSS3动画（简单动画的实现，如旋转等）

```
依靠CSS3中提出的三个属性：transition、transform、animation
1、transition：定义了元素在变化过程中是怎么样的，包含transition-property、transition-duration、	transition-timing-function、transition-delay。
2、transform：定义元素的变化结果，包含rotate、scale、skew、translate。
3、animation：动画定义了动作的每一帧（@keyframes）有什么效果，包括animation-name，animation-		duration、animation-timing-function、animation-delay、animation-iteration-count、		animation-direction
```

### 55、如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）

```
多数显示器默认频率是 60Hz ，即 1 秒刷新 60 次，所以理论上最⼩间隔为 1/60*1000ms ＝ 16.7ms
```

### 56、::before 和 :after中双冒号和单冒号（伪类和伪元素） 有什么区别？解释一下这2个伪元素的作用

```
伪类用于选择元素的某种状态或特定条件下的元素。例如，当鼠标悬停在一个链接上时，可以使用伪类来改变链接的颜色。伪类前面用一个冒号（:）表示。

伪元素用于创建元素的一部分并为其应用样式，通常用于向元素添加内容或修饰。伪元素前面用两个冒号（::）表示（在旧版本的 CSS 中可以用一个冒号），以区分它们与伪类。


单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）

双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，
比如:first-line、:first-letter、:before、:after等，
而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。

想让插入的内容出现在其它内容前，使用::before，否者，使用::after；
在代码顺序上，::after生成的内容也比::before生成的内容靠后。
如果按堆栈视角，::after生成的内容会在::before生成的内容之上
```

### 57、在网页中的应该使用奇数还是偶数的字体？为什么呢？

```
使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px时用的是小一号的点。（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。
```

### 58、怎么实现响应式布局？

```
1、百分比布局 
2、rem布局 
3、媒体查询 @media screen       
4、vh、vw
5、viewport
```

### 59、localStorage 和sessionStorage cookie的区别

```



```

### 60、localStorage能跨域访问吗？

```




```



## 二、Javascript

### 1、代码规范

```
1、变量  声明变量必须加上var关键字，而且每个var只声明一个变量，增加可读写。
2、常量 常量的命名方式：用大写字符，并用下划线分隔。
3、with(){}  尽量少用。
4、缩进  用4个空格作为一缩进，而不是使用tab
5、字符串过长截取   每行代码不超过80个字符。如代码过长，可使用+运算符拼接。
8、构造函数  对于构造函数，命名采用首字母大写，其他函数一律小写。
9、注释  合理的加上注释，有利于后期维护，提高可读性。
10、{}和[]   使用{}代替new Object()，使用[]代替new Array()
11、单引号（'） 尽量使用单引号（'），只在JSON文件中使用双引号。
12、变量和函数声明  变量名和函数名在JavaScript机制下会发生声明提升（也就是会提前到顶部声明），所以建议变量和函数应该在使用前声明。
13、使用===和!==代替==和!=  在JavaScript中，比较运算符进行计算时会进行强制转换，==和!=会产生一些意想不到的结果，所以应该用“严格相等”===
14、换行  在语句块和下一个语句之间留一个空行，提高可读性。
15、命名  构造函数或类名使用驼峰式命名
16、语句  对于复合语句，if, for, while, do, switch, try … catch 等代码体，函数定义的函数体，对象的定义等都需要放在花括号'{}'里面。
17、for-in  对于数组，尽量避免使用for-in
```

### 2、数组和字符串常用方法

| **方法**      | **含义**                                                     | **发音/邪音** |
| ------------- | ------------------------------------------------------------ | ------------- |
| concat()      | 将多个数组拼接成一个数组<br /><br /><br />const arr1 = [1, 2]; <br />const arr2 = [3, 4];<br /> const arr3 = arr1.concat(arr2); // [1, 2, 3, 4]<br /><br />不会改变原数组 |               |
| join()        | 将数组转化为字符串<br />                                     |               |
| pop()         | 删除数组最后一个元素<br />                                   |               |
| shift()       | 删除数组第一个元素                                           |               |
| reverse()     | 数组翻转                                                     |               |
| push()        | 数组末尾添加元素                                             |               |
| unshift()     | 数组开头添加元素                                             |               |
| sort()        | 数组排序                                                     |               |
| indexOf()     | 主要用于在数组中查找数组元素第一次出现的位置                 |               |
| lastIndexOf() | 主要用于在数组中查找数组元素最后一次出现的位置               |               |
| splice()      | 方法向/从数组中添加/删除项目，然后返回被删除的项目           |               |
| slice()       | 以从数组中返回start下标开始取值，直到end下标结束.            |               |
| filter()      | 过滤器，留下符合条件的会形成一个新数组                       |               |
| map()         | 主要用于对每个数组里面的元素执行相同的函数来创建新的数组     |               |
| some()        | 方法用于检测数组中的元素是否满足指定条件，返回值为布尔类型   |               |
| every()       | 主要用于检查数组中每个元素是否符合函数的条件，如果其中有一个不符合，则返回false |               |
| reduce()      | 求和操作，主要是对数组中的每个元素执行函数，生成一个值。     |               |
| flat()        | 将多维数组转成一维数组                                       |               |
| find()        | 查找数组第一个符合条件的元素                                 |               |
| findIndex()   | 查找数组第一个符合条件的元素的下标                           |               |
| from()        | 将类数组转真正的数组                                         |               |
| **方法**      | **含义**                                                     | **发音/邪音** |
| substring()   | 截取字符串                                                   |               |
| charAt()      | 查找字符串                                                   |               |
| toUpperCase() | 转大写                                                       |               |
| toLowerCase() | 转小写                                                       |               |
| split()       | 字符串转数组                                                 |               |
| indexOf()     | 返回子字符串第一次出现的位置                                 |               |
| lastIndexOf() | 返回子字符串最后一次出现的位置                               |               |
| slice()       | 截取字符串                                                   |               |
| replace()     | 字符串替换                                                   |               |
| padStart()    | 用于头部补全                                                 |               |
| padEnd()      | 用于尾部补全                                                 |               |
| trimStart()   | 消除字符串头部的空格                                         |               |
| trimEnd()     | 消除尾部的空格`                                              |               |
| trim()        | 方法用于删除字符串的头尾空白符                               |               |
| repeat()      |                                                              |               |
| startsWith()  | 返回布尔值，表示参数字符串是否在原字符串的头部。             |               |
| endsWith()    | 返回布尔值，表示参数字符串是否在原字符串的尾部。             |               |

### 3、JS的三大组成部分

```
ECMAscript:主要用来描述javascript的语法部分   
BOM:结合js及BOM提供的属性和方法对浏览器进行操作  
DOM：结合js及DOM提供的属性和方法对HTML和XML文档进行操作 
```

### 4、JS的数据类型？怎么检测数据类型的？

```
Js的基本数据类型有：string、number、boolean、null、undefined，ES6中symbol
复杂数据类型有：object:`Array` ，`Function`， `Date`， `RegExp`

typeof()  intanceof()  constructor() 

typeof()测试数据类型的时候结果：
	“number”、“string”、“boolean”、“undefined”、“object”、“function”
	
如何判断一个元素是否是数组
	1、instanceof 操作符判断
	  console.log(arr instanceof Array);
	2、arr.constructor === Array
	3、Array.isArray(arr)
```

### 5、  JS强制类型转换

| **方法**   | **含义**       | **发音/邪音** |
| ---------- | -------------- | ------------- |
| parseInt() | 转换数值类型   | 怕思因特      |
| Number()   | 转换数值类型   | 囊波儿        |
| ToString() | 转换字符串类型 | 兔思吹        |
| Boolean()  | 转换对象类型   | 布里恩        |

### 6、常见的dom操作？ 

| **方法**             | **含义**             | **发音/邪音**   |
| -------------------- | -------------------- | --------------- |
| createElement(‘div’) | 创建dom元素          | 亏爱特 爱里们特 |
| appendChild()        | 把节点添加到某元素中 | 额喷的 拆哦的   |
| parentNode           | 寻找父节点           | 拍润特 耨的     |
| remove()             | 删除节点             | 瑞 木屋         |
| removeChild()        | 删除子节点           | 瑞木屋 球儿得   |
| insertBefore()       | 之前插入子节点       |                 |
| children             | 所有子节点           |                 |
| nodeType             | 节点类型             |                 |
|                      |                      |                 |

### 7、数组去重的方法

```
数组去重的方法有很多，我先说一下我常用的方法
1、首先声明一个新数组，并遍历原数组使用indexOf方法进行判断新数组中是否有原数组中的元素，如果没有，就往新数组里添加，如果有则不添加

let arr=[1,2,3,4,5,5,3,2,6,7];
     let arr2=[];
     arr.forEach(item=>{
        if(arr2.indexOf(item)===-1){
            arr2.push(item);
        }
     })
     console.log(arr2);

2、使用new Set 进行去重，然后再转为数组
	 var arr1 = [...(new Set(arr))]
	 var arr1 = Array.from(new Set(arr))
	 
3、filter  +  indexOf	
    //var arr1 = arr.filter(( item,index) => {
          return  arr.indexOf(item) === index
    })
```

### 8、如何阻止事件冒泡 和默认事件

```
阻止冒泡事件：

非IE浏览器使用stopPropagation()方法可以清除事件冒泡		邪音：思倒破 破破给甚
IE浏览器使用cancelBubble()清除事件冒泡
 //非IE
                if(e.stopPropagation){
                    e.stopPropagation();
                }
                else{
                    e.cancelBubble = true; 

                }
               
阻止默认事件：

<a href="http://baidu.com" id="baidu">百度</a>

 document.querySelector("#baidu").addEventListener("click",function(e){
                alert("baidu");
                e.preventDefault();//阻止默认事件
               })


```

### 9、数组的冒泡排序原理及其实现

```
原理：相邻的两项进行比较，如果前面的一项大于（小于）后面的项，则交换位置。直到最大（最小）数沉底为止。
 var ary=[21,32,2,9,4];
        function bubbleSort(ary){
            for(var i=0; i<ary.length; i++){//正在进行第几次循环
                for(var j=0; j<ary.length-1-i; j++){//本次循环需要执行几次
                    if(ary[j]>ary[j+1]){
                        var tmp=ary[j];
                        ary[j]=ary[j+1];
                        ary[j+1]=tmp;
                    }
                }
            }
            return ary;
        }
       document.write(bubbleSort(ary));
```

### 10、怎么用JS获取一个盒子的宽高

```
var box = document.getElementById("box")
//获取元素设置的高度，为带单位的字符串类型
var contentHeight = window.getComputedStyle(box,null).height 
//获取元素设置的高度，为不带单位的数值类型
box.clientHeight 
//获取盒子自身实际高度，为不带单位的数值类型
box.offsetHeight
```

### 11、 ==  和  ===的区别  

```
== 	会自动转换类型再去比较值是否相等
===	不会自动转类型，并且进行比较时值与数据类型都要相等

！=   ！==
```

### 12、undefined和null的区别  

```
undefined：声明未赋值，或者是对象里的一个属性未定义
什么情况下会产生undefined
 //1、定义变量未赋值

 //2、对象未定义某个属性，那么对象里的找个属性值为undefined

      var obj={name:"张三"};

      console.log(obj.age);

 //3、函数没有返回值 ，那么函数的返回值是undefined

null：声明了也赋值了，赋的值就是个null，因为null它是一个空，不占用空间
```

### 13、JS遇到过哪些兼容性问题

```
是要处理IE浏览器和非IE浏览器之间的兼容

1、获取滚动距离的兼容处理
	document.documentElement.scrollTop    非IE
    document.body.scrollTop   ==> 兼容IE  
2、阻止冒泡的兼容处理
	e.stopPropagation()	非IE   ||    e.cancelBubble 兼容IE
3、阻止默认行为
	preventDefault( ) 非IE  ||  	return  false  兼容IE
4、DOM2添加监听事件的兼容处理
	addEventListener 非IE || attachEvent  兼容IE
5、删除DOM2事件监听
	removeEventListener 非IE  || detachEvent  兼容IE
    。。。
```

### 14、window.onload和$(document).ready()的区别。

```
1、window.onload和ready都是属于就绪函数、区别是window.onload只执行一次、ready会执行多次。
2、window.onload是在页面资源(比如图片和媒体资源都加载完成再执行，它的加载速度远慢于DOM的加载速度)
3、ready是在dom树结构加载完成后就会执行
4、所以ready要比onload要先执行
```

### 15、说说你对this的理解

​      介绍一下this指向？

​      箭头函数的this指向？

​      如何改变this指向？

```
首先this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁
比如：
   1、在全局的环境中，this指向的是window
   2、在函数中，有两种情况，非严格情况下this指向的是window，在严格情况下this指向undefined
   3、在对象中，如果函数被上一级对象调用，那么this指向的是上一级对象，否则指向全局window
	     var title="hello";
         var obj={
            id:100,
            title:"你好",
            run:function(){
                console.log(this.title); //this指向 obj 输出你好
                function  fn1() {
                    console.log(this.title);  //this指向window 输出 hello
                }
                fn1();
                
            }
         }

         obj.run();
	 4、在构造函数中，this指向的是new出来的那个对象
	 
在箭头函数中this指向谁？
答：在箭头函数中，this指向的是父级程序的this指向，如果没有父级程序或者父级程序没有指向，箭头函数的this指向的是window
   var obj1={
         title:"李四",
         say:function(){

            console.log(1111,this);
            const fn=()=>{

                console.log(this.title);//this 指向 上一级程序 say的this指向   输出 李四
                
            }
            fn();

         }

       }
       obj1.say();


```

### 16、作用域及作用链

```
作用域:变量或者函数可访问的范围
 	全局作用域： 在函数的外部使用var声明的变量，可以在任意位置访问；
 	局部作用域（函数作用域）：在函数中使用var关键字声明的变量，只能在函数的内部访问;
	ES6又增加了一种作用域：块级作用域，比如说es6中let和const声明的变量都具有块级作用域
	
 作用域链： 一般情况下，变量取值会到创建这个变量的函数作用域中取值。但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。
```

### 17、深拷贝和浅拷贝

```
都是引用数据类型来说的，基本数据类型没有深拷贝和浅拷贝一说，都是对对象的拷贝方式

浅拷贝\深拷贝

	浅复制只复制一层对象的属性，而深复制则递归复制了所有层级
						   而深拷贝又分为三种
						   1、可以使用递归
						   2、可以JSON，JSON.stringify,JSON.parse
						   3、可以使用jq中的xtend
						   
						   JSON.stringify,JSON.parse 进行深拷贝的缺陷：
						   1、如果里面有时间对象，则 JSON.stringify 后再 JSON.parse 的结果，时间							  将转为字符串的形式，而不是对象的形式
						   2、如果数组里面有，undefined，Function RegExp (正则表达式的缩写)、Error 对象，则序列化的结果								 将只得到空对象；
						   3、
						   4、对象循环引用无法拷贝

一、对象的深浅拷贝
深拷贝
1、原生实现
function deepCopy(p,c){
    var i;
    c = c||{};
    for(i in p){
        if(p.hasOwnProperty(i)){
            if(typeof(p[i])==="object"){
                c[i] = Array.isArray(p[i])?[]:{};
                deepCopy(p[i],c[i]);
            }else{
                c[i] = p[i];
           }
        }
    }
    return c;
}

2、使用 JSON 全局对象的 parse 和 stringify 方法来实现深复制
    function jsonClone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
    var clone = jsonClone({ a:1 });
 (https://www.cnblogs.com/kongxy/p/4618173.html)
 对象的属性分为可枚举和不可枚举之分，它们是由属性的enumerable值决定的。可枚举性决定了这个属性能否被for…in查找遍历到。for...in遍历可枚举的属性和原型链上的可枚举的属性。
这种方法有一个缺点就是只能复制对象中的可枚举属性，其他属性不可复制，例如function。这种简单粗暴的方式有局限性，当值为undefined、function、symbol会在转换过程中被忽略。

这时可以采用如下方法：
function getType(obj) {
  //tostring会返回对应不同的标签的构造函数
  var toString = Object.prototype.toString;
  var map = {
    '[object Boolean]'  : 'boolean', 
    '[object Number]'   : 'number', 
    '[object String]'   : 'string', 
    '[object Function]' : 'function', 
    '[object Array]'    : 'array', 
    '[object Date]'     : 'date', 
    '[object RegExp]'   : 'regExp', 
    '[object Undefined]': 'undefined',
    '[object Null]'     : 'null', 
    '[object Object]'   : 'object'
  };
  if(obj instanceof Element) {
    return 'element';
  }
  return map[toString.call(obj)];
}
 
function deepCopy(obj) {
  var type = getType(obj);
  var obj;
  if(type === 'array'){
    obj = [];
  } else if(type === 'object'){
    obj = {};
  } else {
    //不再具有下一层次
    return obj;
  }
  if(type === 'array'){
    for(var i = 0, len = obj.length; i < len; i++){
      obj.push(deepCopy(obj[i]));
    }
  } else if(type === 'object'){
    for(var key in obj){
      obj[key] = deepCopy(obj[key]);
    }
  }
  return obj;
}

3、$.extend(),设置为true是深拷贝
var x = {
    a: 1,
    b: { f: { g: 1 } },
    c: [ 1, 2, 3 ]
};

var y = $.extend({}, x),          //shallow copy
    z = $.extend(true, {}, x);    //deep copy

y.b.f === x.b.f       // true
z.b.f === x.b.f       // false

4、Object.assign(...)

对象的浅拷贝
1、自己封装函数实现
 var obj = { a:1, arr: [2,3] };
 var shallowObj = shallowCopy(obj);

function shallowCopy(src) {
  var dst = {};
  for (var prop in src) {
    if (src.hasOwnProperty(prop)) {
      dst[prop] = src[prop];
    }
  }
  return dst;
}
2、直接赋值
	var obj = {a:1};
	var obj1 = obj;
二、数组的深浅拷贝
浅拷贝
1、直接赋值	
	var arr = [12,34,343];
	var arr1 = arr;
2、自己封装函数实现

深拷贝
1、自己封装函数实现
2、slice()
// 当数组里面的值是基本数据类型，比如String，Number，Boolean时，属于深拷贝
// 当数组里面的值是引用数据类型，比如Object，Array时，属于浅拷贝
3、concat()  
// 当数组里面的值是基本数据类型，比如String，Number，Boolean时，属于深拷贝
4、使用扩展运算符实现深拷贝
// 当value是基本数据类型，比如String，Number，Boolean时，是可以使用拓展运算符进行深拷贝的
// 当value是引用类型的值，比如Object，Array，引用类型进行深拷贝也只是拷贝了引用地址，所以属于浅拷贝
```

### 18、ES6新特性

```
	es6新增的特性挺多的
	1.	let与const
	1.	模块化开发
	2.	箭头函数
	3.	函数参数默认值
	4.	模板字符串
	5.	解构赋值
	6.	对象属性简写
	7.	Promise
	9.	class 类
	10.	扩展运算符
	11、新增了数组、字符串、对象的方法
	12、for...of 
	13、async 
```

### 19、箭头函数和普通函数的区别

```
区别：
	1、语法不同。
	2、箭头函数是匿名函数，不能作为构造函数，不能实例化（不能new）。
	3、箭头函数没有arguments，取而代之用rest参数...解决。
	4、箭头函数没有原型属性 prototype。
	5、箭头函数和普通函数的this指向不一样，箭头函数this指向上一级程序的this指向。
	6、箭头函数不能当做Generator函数,不能使用yield关键字.
```

### 20、let const var的区别

```
1、var声明的变量会挂载到window上，而let和const声明的变量不会。
2、var声明变量存在变量声明提升，let和const不存在变量声明提升。
3、let和const声明的变量有块作用域。
4、同一作用域下let和const不能声明同名变量，而var可以。
5、let和const声明的变量存在 会造成暂时性死区。
6、const声明变量的时候必须赋初始值
7、const声明变量不能修改
```

### 21、说说对promise的理解

```
Promise是异步编程的一种解决方案，主要解决由于异步请求的多层嵌套造成的回调地狱问题。
解决异步编程的方案：回调函数 async await  generator promise

async和promise的区别?
答:首先他们的相同点都是异步编程的一种解决方案，async await后面跟一个promise，async主要把异步变为同步，解决了链式操作。

Promise有三个状态和两个过程
	三个状态：pending（初始状态）、fulfilled（成功状态）、rejected（失败状态）；
	
	两个过程：pending==>fulfilled的过程和pending==>rejected的过程。
	缺点：promise的状态一旦改变则不会再变，是不可逆的,无法阻止状态的改变
	
	
	方法：Promise是一个构造函数，自身有reject、resolve这几个方法
	
	原型方法：then()、catch() 和 finally()。它们属于微任务，优先级高于 setTimeout 等宏任务。
	
	then:处理 Promise 的成功（fulfilled）和失败（rejected）状态
	catch:专门处理 Promise 链中的失败状态
    finally:无论 Promise 成功或失败，最终必须执行的回调（如清理资源）

        new Promise((resolve, reject) => {
            resolve(10000);
        }).then(res => {
            console.log('成功了');

        }).catch(err => {
            console.log('失败了');
        }).finally(() => {

            console.log('不管成功还是失败都会执行');

        })

	
	
	静态方法：all、race、any
	

	all方法是：只有所有的promise对象都成功了，就会走fulfilled,只要有一个失败 就会走reject
	race方法是：最先执行返回成功,那么走fulfilled,最先执行返回失败，走reject
	any方法：只要有一个成功，那么就会走fulfilled，否则走reject
	
	什么时候使用all方法：比如：当一个页面有多个ajax请求，想请求结果都成功之后再处理结果。

    js他是单线程的，但是它分为同步任务和异步任务，同步任务会放到主线程中去执行，
    
Promise串行、Promise并行

在ES6中由于增加了promise，所以在异步任务中又分为宏任务和微任务
宏任务：setTimeout、setInterval、requestAnimationFrame
	1、宏任务所处的任务队列就是宏任务队列
	2、第一个宏任务队列中只有一个任务：执行主线程的js代码
	3、宏任务队列可以有多个
	4、当宏任务队列中的任务全部执行完会查看是否有位任务队列，如果有先执行微任务中的所有任务，如果没有就查看是否有宏任务
微任务：promise.then(回调)   process.nexttick(  )
	1、微任务所处的队列就是微任务队列
	2、只有一个微任务队列
	3、在上一个宏任务队列执行完毕后执行，如果有为任务队列就会执行微任务中的所有任务。
		首先在宏任务的队列中选取出第一个任务，执行完毕后取出为任务队列中的所有任务顺序执行，之后再取出宏任务，周而复始，直至两个队列的任务都取完。
		
		
		setTimeout(function(){
            console.log(1);
        },0);
        new Promise(function(a,b){
            console.log(2);
            for(var i=0;i<10;i++){
                i==9&&a();
            }
            console.log(3)
        }).then(function(){
            console.log(4)
        });
        console.log(5);
        
	正确输出顺序为：2，3，5，4，1；
	
	微任务先执行，宏任务后执行
```

### 22、http请求

```
指从客户端到服务器端的请求消息
```

### 23、http请求的方式	

```
HTTP请求的方法：
	HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
	HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法
```

### 24、get请求与post请求的区别

```
1、get和post在HTTP中都代表着请求数据，其中get请求相对来说更简单、快速，效率高些 
2、get相对post安全性低
3、get有缓存，post没有
4、get体积小，post可以无限大
5、get的url参数可见，post不可见
6、get只接受ASCII字符的参数数据类型，post没有限制
7、get请求参数会保留历史记录，post中参数不会保留
8、get会被浏览器主动catch，post不会，需要手动设置
9、get在浏览器回退时无害，post会再次提交请求


get:一般用于信息获取，使用url传递参数，对所发送信息的数量也有限制，一般在2000个字符，有的浏览器是8000个字符
post：一般用于修改服务器上的资源，对所发送的信息没有限制（post通过请求体将数据传向后台）
	在以下情况中，使用post请求
	1.无法使用缓存文件（更新服务器上的文件或数据库）
	2.向服务器发送大量数据（post没有数据限制）
	3.发送包含未知字符的用户输入时，post比get更稳定也更可靠
```

### 25、http请求的状态码

```
http的状态码有很多
http状态码分为五类：
	1开头的代表信息状态码
	2开头的代表成功状态码
	3开头的代表重定向状态码
	4开头的代表客户端错误状态码
	5开头代表服务端错误状态码
常用状态码有：
	200：请求成功
	301：被请求的资源已经永久移动到新位置
	304：所请求的资源未修改（缓存）。
	404：服务器无法根据客户端的请求找到资源
	500：服务器内部错误，无法完成请求
	503：由于超载或系统维护，服务器暂时无法处理客户端请求
301与303的区别：
	301转向(或叫301重定向，301跳转)是当用户或搜索引擎向网站服务器发出浏览请求时，服务器返回的HTTP数据流中头信息(header)中的状态码的一种，表示本网页永久性转移到另一个地址。
	
	303状态码：对于POST请求，它表示请求已经被处理，客户端可以接着使用GET方法去请求Location里的URI。
```

### 26、网络请求的方式

```
1、原生ajax
2、jq中的ajax
3、es6中的fetch
4、axios.js
```

### 27、同源策略

```
是浏览器的一个重要的安全策略，浏览器不允许访问不同源的资源。如果缺少了同源策略，浏览器很容易受到 XSS、 CSFR 等攻击。由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，现在所有支持 JavaScript 的浏览器都会使用这个策略.
```

### 28、同源

```
同协议、同域名、同端口
只要有一个不一样 就会产生跨域问题
```

### 29、跨域

```
访问了不同源的资源就是跨域，比如我们现在的项目都是前后端分离的项目，前端的地址和后端的地址不一样，就会产生跨域   http://localhost:8080   http://localhost:3000
```

### 30、跨域解决方案

```
1、通过jsonp跨域
2、反向代理
3、后端解决
4、服务器：nginx代理跨域
```

### 31、本地存储都有什么及区别 

```
本地存储有localStorage、sessionStorage和cookie，但他们之间是有区别的。
总结：
1、浏览器兼容性：它们都是用来保存信息的。cookie兼容所有的浏览器，低版本的浏览器不支持localStorage和sessionStorage（IE6,7,8）
2、使用方面： cookie需要程序员自己封装函数实现，localStorage、sessionStorage提供了友好的API
3、生成及存储位置
	cookie客户端、服务器端都生成，通过浏览器存储在客户端，每次发送请求的时候会携带cookie.
	localStorage、sessionStorage，客户端生成，存储在客户端（浏览器端）和服务器没有半毛钱关系
4、大小区别：
	localStorage、sessionStorage一个源下最多只能存储5MB左右,(可以存储5m)  
	cookie有存储的大小限制，一般一个源（一个域下）只能存储4KB内容(cookie只能存储4kb)。
5、有效期的区别：
	localStorage可以长期存储数据，浏览器关闭后数据不丢失，除非手动删除。
	sessionStorage存储数据在浏览器关闭时自动删除。
	Cookie可设置过期时间(如果未设置过期时间，那么关闭浏览器就会自动删除)，过期之后浏览器关闭后自动消失。
6、安全问题：
	cookie会把消息上传到服务器端最不安全。
	localstorage和sessionstorage都会留在本地所以更安全。
    
7、跨域问题：localStorage与sessionStorage的区别：
    localStorage只要在相同的协议、相同的主机名、相同的端口下，即同源就能读取/修改到同一份localStorage数据。
    sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。
    Cookie可以跨域访问（同一域名下的不同二级域名下设置Cookie.domain,可以进行跨域访问）
    
    存入到 localStorage 和 sessionStorage 的都是字符串，因此如果是要将一个对象存入 localStorage/sessionStorage 的话，是需要先用 JSON.stringify() 序列化对象的，读取时也需要 JSON.parse() 转换为真正的 JS 对象。

```

### 32、了解Eventloop（事件循环）吗？

```
js是单线程语言，一次只能完成一个任务，如果同时完成多个任务怎么办？js把任务分为同步和异步任务，把所有的同步放到主线程上去执行，把所有的异步任务放到事件队列里去，当所有的同步任务都执行完之后，去事件队列中看看有没有没有执行的异步任务，如果有把需要先执行的异步任务拉到主线程上去执行，当这个任务执行完后，再去事件队列里看有没有没完成的任务，如果有再把任务拉到主线程去执行，这样就形成一个事件循环。


js是单线程的，但是它分为同步任务和异步任务，同步任务会放到主线程中去执行，执行栈在同步代码执行完成后，优先检查微任务队列是否有任务需要执行，如果没有，再去宏任务队列检查是否有任务执行，如此往复。微任务一般在当前循环就会优先执行，而宏任务会等到下一次循环，因此，微任务一般比宏任务先执行，并且微任务队列只有一个，宏任务队列可能有多个。



在ES6中由于增加了promise，所以在异步任务中又分为宏任务和微任务

宏任务：setTimeout、setInterval、requestAnimationFrame
	1、宏任务所处的任务队列就是宏任务队列
	2、第一个宏任务队列中只有一个任务：执行主线程的js代码
	3、宏任务队列可以有多个
	4、当宏任务队列中的任务全部执行完会查看是否有位任务队列，如果有先执行微任务中的所有任务，如果没有就查看是否有宏任务
微任务：promise.then(回调)  promise.catch()   process.nexttick(  )
	1、微任务所处的队列就是微任务队列
	2、只有一个微任务队列
	3、在上一个宏任务队列执行完毕后执行，如果有为任务队列就会执行微任务中的所有任务。
		首先在宏任务的队列中选取出第一个任务，执行完毕后取出为任务队列中的所有任务顺序执行，之后再取出宏任务，周而复始，直至两个队列的任务都取完。
		
		
		setTimeout(function(){
            console.log(1);
        },0);
        new Promise(function(a,b){
            console.log(2);
            for(var i=0;i<10;i++){
                i==9&&a();
            }
            console.log(3)
        }).then(function(){
            console.log(4)
        });
        console.log(5);
        
	正确输出顺序为：2，3，5，4，1；
```

### 33、谈谈你对js闭包的理解。

```
首先 闭包就是函数外部能够读取函数内部的变量
形成闭包的条件
1.函数嵌套函数
2.函数内部调用函数外部的变量
3.外部的函数被调用
优点：函数外部能够读取函数内部的变量，避免了全局变量被污染
缺点：由于闭包会使函数中的变量保存在内存中，内存消耗很大，而且容易造成内存泄漏
解决办法: 在退出函数前将不使用的局部变量删除，或者直接将赋值的变量等于null(increment()=null)

使用场景：封装的防抖、节流函数

function count() {
	var m = 0
	var fn = function() {
		m ++
		console.log(m);
	}
	return fn
}
var c = count();
 c();
 c();
 c();
 
```

###  34、解释一下原型以及原型链

```
原型：构造函数的prototype就是构造函数new出来的对象的原型

原型链就是通过原型继承在原型之间建立起来的链型结构被称为原型链
对象属性查找顺序为：
    每一个实例对象都有一个私有属性__proto__,指向它的构造函数的原型对象(prototype)。原型对象也有自己的__proto__，层层向上直到一个对象的原型对象为null。这一层层原型就是原型链。
```

### 35、JS创建对象的方法

```
0，字面量方式
1. new一个对象
2，工厂函数方式
3，构造函数模式 
4，原型模式 
5，混合构造函数和原型模式
6，动态原型模式 
7，寄生构造函数模式 
8，稳妥构造函数模式
```

### 36、JS实现继承的方法

```
1，原型链继承
2，借用构造函数继承
3，组合继承(原型+借用构造)

```

### 37、说说jsonp的原理

```
利用script标签的src的跨域属性

1）创建script标签
		var script = document.createElement('script');
2)设置回调函数
	function getData(data){
		//数据请求回来会被触发的函数
		console.log(data);
	}
3)设置script标签的src属性，设置请求的地址
		script.src = 'http://localhost:3000?callback=getData'
4)让script生效
		document.body.appendChild(script)
5）后台设置代码
	(比如后端用的是node搭建的服务器)
  ...获取到callback的值
  	然后调用callback的值（前端函数）并传递数据
  	var data = {
        name:"jxk",
        age:20
  	}
  	var scriptStr = `${query.callback}(${JSON.stringify(data)})`
  	res.end(scriptStr)
```

### 38、前端性能优化的方法？

```
（1）、当需要设置的样式很多时设置className而不是直接操作style。
（2）、避免在页面的主题布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。
（3）、用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。
（4）、减少http请求次数：CSS Sprites，JS、CSS源码压缩，图片大小控制合适；网页GZIP压缩，CDN托管，data缓存，图片服务器。
（5）、图片预加载，将样式表放在顶部，将脚本放在底部，加上时间戳。
（6）、前端模板 JS+数据，减少由于html标签导致的贷款浪费，前端用变量保存AJAX请求结果，每次操作本地数据，减少请求次数。
（7）、少用全局变量，缓存DOM节点查找的结果。减少IO（输入/输出）读取操作。
（8）、避免使用CSS Expression(css 表达式)又称动态属性（Dynamic properties）。
（9）、减少DOM操作；部署前，图片压缩、代码压缩；优化js代码结构，减少冗余代码；减少http请求，合理设置http缓存；使用内容分发cdn加速；静态资源缓存；图片延迟加载；
```

### 39、for in  和  for  of的区别

```
for。。。in的特点：
    1.index索引为字符串型数字，不能直接进行几何运算。
    2.遍历顺序有可能不是按照实际数组的内部顺序。
    3.使用for in会遍历数组所有的可枚举属性，包括原型。所以for in更适合遍历对象，不要使用for in遍历数组。
    对象的遍历（for...in..  keys() values() entries()）
for…of的特点：
    for..of适用遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合.但是不能遍历对象,因为对象没有迭代器.与forEach()不同的是，它可以正确响应break、continue和return语句
    for-of循环不支持普通对象，如果要迭代一个对象的属性，可以用for-in循环（这也是它的本职工作）或内建的Object.keys()方法
    
forEach更多的用来遍历数组

for in 一般常用来遍历对象或json

for of数组对象都可以遍历，遍历对象需要通过和Object.keys()

for in循环出的是key，for of循环出的是value
```

### 40、forEach()和map()和every()和some()和filter()的区别

```
首先forEach、map、filter、some都是遍历数组的方法，都是用来遍历数组。
forEach，没有返回值
	不能响应return、break
map：返回值为新的数组
	按照原数组的元素顺序依次处理元素，返回一个处理后的新数组，数组元素是值类型则原数组不变，数组元素为引用类型，则原数组改变
filter：返回值为新的数组
	过滤指定数组中所有符合条件的元素，返回一个新数组，原数组不变
some：返回值为boolean类型
	用于检测数组中的元素是否满足指定条件，如果有一个符合条件的就返回true，如果没有符合条件的就返回false，原数组不变
	
every:返回值为boolean类型
	every用于检测数组中的元素是否满足指定条件，所有元素都符合条件才返回true，如果没有符合条件的返回		false，原数组不变。
```

### 41、call()和apply()以及bind()的区别

```
相同点：首先他们都是改变this的指向，然后第一个参数都是this指向谁。
不同点：传值方式不同
	Call方法：第二个参数是一个序列模式的，依次传入
	Apply方法：传入的第二个参数是一个数组的格式
	bind方法：首先他是改变完this的指向会生成一个新的函数，所以需要调用，然后他的第二个参数也是序列模式。
```

```
var obj = {
            title: "hello",
            say: function (name, from) {
                console.log(this.title);
                console.log(from);
                console.log(name);

            }
        }

        var obj2 = {
            title: "你好"
        }

        obj.say.call(obj2, "张三", "北京"); //传参方式为序列
        obj.say.apply(obj2, ["李四", "上海"]); //传参方式为数组
        obj.say.bind(obj2, "王五", "深圳")();
```



### 42、变量的声明提升

```
var有变量声明提升,将变量的声明提升到当前的作用域最开始的位置,但赋值还是在原来位置
函数也存在声明提升.
函数的升明提升优先于变量的声明提升

console.log(a);
var a = 100;
```

### 43、原生Ajax请求的五个步骤

```
1.创建一个XMLHttpRequest异步对象
2.设置请求方式和请求地址
3.用send发送请求
4.监听状态变化
5.接收返回的数据并处理数据

通过XMLHttpRequest对象，向服务器发送请求，返回数据由javascript+css进行处理，从而渲染DOM
```

### 44、new关键字的执行过程

```
(一)	首先创建一个空对象
(二)	将这个空对象赋值给this，并将this的__proto__指向构造方法对象的原型
(三)	对this这个对象进行属性的添加，并初始化
(四)	将this对象返回
```

### 45、自己实现bind函数

```

```

### 46、setTimeout和setInterval的区别

```
	1.setInterval在执行完一次代码之后，经过了那个固定的时间间隔，它还会自动重复执行代码，而setTimeout只执行一次那段代码。
	setTimeout用于延迟执行某方法或功能
	setInterval则一般用于刷新表单，对于一些表单的假实时指定时间刷新同步
```

### 47、防抖和节流

```
https://www.cnblogs.com/youma/p/10559331.html
防抖和节流都是用来处理高频事件。
两者都是优化高频率执行js代码的一种手段。
函数防抖（debounce）：
	一个需要频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效。（主要应用场景有：input验证、搜索联想、resize）
	（大白话：只执行最后一次）
	
函数节流（throttle）：
	一个函数执行一次后，只有大于设定的执行周期后才会执行第二次。（主要应用场景有：scroll、touchmove）
	（大白话：控制执行次数）
```

### 48、浏览器的缓存

```
https://www.sohu.com/a/280389359_120047065

https://www.cnblogs.com/mmzuo-798/p/6295590.html

解决浏览器缓存的方法：
1、meta方法
//不缓存
<META HTTP-EQUIV="pragma" CONTENT="no-cache"> 
<META HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate"> 
<META HTTP-EQUIV="expires" CONTENT="0">

2、jquery ajax清除浏览器缓存 
直接用cache:false,
$.ajax({
     url:'www.haorooms.com',
     dataType:'json',
     data:{},
     cache:false,
     ifModified :true ,
 
     success:function(response){
         //操作
     }
     async:false
  });
  
  3、方法三：用随机数，随机数也是避免缓存的一种很不错的方法！
  
  <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <input type="text">
    <img id="code" src="http://apis.90000p.com/eshare/admin/getVerify" alt="" srcset="">

    <script>
        document.getElementById("code").addEventListener("click",function(){

           this.src="http://apis.90000p.com/eshare/admin/getVerify?t="+Math.random();
        })
    </script>
</body>
</html>

   URL 参数后加上 "?ran=" + Math.random(); //当然这里参数 ran可以任意取了
```

### 49、if有作用域吗

```
在 JavaScript 中，if 语句本身不直接创建作用域，但其内部的代码块（{}）是否会形成作用域，取决于变量声明的方式（var、let、const）。具体如下：

1. 使用 var 声明变量
没有块级作用域：var 声明的变量会提升到最近的函数作用域或全局作用域，因此 if 的代码块不会限制其作用域。


if (true) {
  var a = 10;
}
console.log(a); // 输出 10（变量泄露到外部作用域）

2. 使用 let 或 const 声明变量
有块级作用域：let 和 const 是 ES6 新增的声明方式，会在 if 的代码块内形成块级作用域，变量仅在 {} 内部有效。

 
if (true) {
  let b = 20;
  const c = 30;
}
console.log(b); // ReferenceError: b 未定义
console.log(c); // ReferenceError: c 未定义
3. 关键总结
声明方式	if 代码块是否形成作用域	变量作用域范围
var	❌ 否	函数/全局作用域
let	✅ 是	块级作用域（{}内）
const	✅ 是	块级作用域（{}内）

```

### 50、面向对象

```
面向对象的方法主要是把事物给对象化，具有相同的属性和方法。
面向对象三个特征：
1、封装、
 平时所用的方法和类都是一种封装
2、继承 
 子类继承父类，子类拥有父类的属性和方法。

js如何实现继承：原型链继承（prototype）、构造函数继承（call）、组合继承 .....

es6 定义类使用 class关键字  继承使用 extends

 3、多态
一个类的方法，不同对象调用，结果不同
```

### 51、js的内置对象

```
 number、Boolean、String、Data、Array 
```

### 52、vue有几种插槽

```
默认插槽，具名插槽，作用域插槽

默认插槽：就是通过替换占位符达到在父组件中更改子组件中内容的效果。
具名插槽：其实就是给子组件中的插槽取一个名字，而父组件就可以在引用子组件的时候，根据这个名字对号入座，将相应内容填充到相应的插槽中。
作用域插槽：通过slot标签来实现作用域插槽
```

### 53、map和set的区别

```
Map：Map对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。构造函数`Map`可以接受一个数组作为参数。
Set：Set对象允许你存储任何类型的值，无论是原始值或者是对象引用。它类似于数组，但是成员的值都是唯一的，没有重复的值。
```

### 54、行内元素和块级元素指的是什么

```
 行内元素只占它对应标签的边框所包含的空间。 
 一般块级元素可以包含行内元素和其他块级元素。
```

### 55、forEach、for in、for of区别是什么？

```
 forEach专门用来循环数组
 for...in 一般循环遍历的都是对象的属性
 for of是ES6新引入的特性。修复了ES5中for in的不足
 允许遍历 Arrays（数组）、Strings（字符串）、Maps（映射）、Sets（集合）等可迭代的数据结构
 for of 支持return, 只能遍历数组不能遍历对象（遍历对象需要通过和Object.keys()搭配使用）
```

### 56、关于JS事件冒泡与JS事件代理（事件委托）

（1）事件冒泡
当一个元素接收到事件的时候 会把他接收到的事件传给自己的父级，一直到window，过程就像冒泡泡 。如果在某一层想要中止冒泡，使用 event.stopPropagation() 。
但是当大量标签大量事件的时候先然不可能为每个元素都加上事件，（事件绑定占用事件，浏览器要跟踪每个事件，占用更多内存。而且并不是所有事件都会被用户使用到）。所以需要事件委托来解决这个问题。
（2）事件委托
将事件给最外层的元素，自己不实现逻辑，由最外层元素来代理。（判断事件源，做不同处理）
    事件委托优点
1.减少内存消耗，提高性能
2.动态绑定事件
3.冒泡、委托对事件连环触发带来的影响
4.替代原生JS中循环绑定事件的操作

```
普通事件绑定，依赖循环，循环次数增加，内存损耗增加

<div id="div">
    <div>adada</div>
    <ul id="ul">
       <li class="li">1</li>
       <li class="li">2</li>
       <li id="li3" class="li">3</li>
       <li class="li">4</li>
       <li class="li">5</li>
    </ul>
  </div>
  <script>

    
    var lis = document.querySelectorAll(".li");
    for (let index = 0; index < lis.length; index++) {
      lis[index].onclick = function () {
        console.log(this.innerHTML);
      }
    }
     
  </script>

事件委托：父节点接受委托给子节点分配点击事件

--------------------------给子元素添加事件----------------------
<div id="div">
    <div>adada</div>
    <ul id="ul">
       <li class="li">1</li>
       <li class="li">2</li>
       <li id="li3" class="li">3</li>
       <li class="li">4</li>
       <li class="li">5</li>
    </ul>
  </div>
  <script>

    
    document.getElementById("div").addEventListener("click", function (e) {
  
      //浏览器兼容性处理
      var event = e || window.event;
      var target = event.target || event.srcElement;
      if (target.className == "li") {
        console.log(e.target.innerHTML);
      }
    })
  
  </script>

终止事件冒泡
方法一：在相应的函数中加上event.stopPropagation()

这是阻止事件的冒泡方法，不让事件向documen上蔓延。

  <div id="div">
    <div>adada</div>
    <ul id="ul">
       <li class="li">1</li>
       <li class="li">2</li>
       <li id="li3" class="li">3</li>
       <li class="li">4</li>
       <li class="li">5</li>
    </ul>
  </div>
  <script>

    document.getElementById("li3").addEventListener("click", function (e) {
  
      console.log("点击了li");
      e.stopPropagation();
    })
  
    document.getElementById("ul").addEventListener("click", function () {
  
      console.log("点击了ul");
    })
  
    document.getElementById("div").addEventListener("click", function (e) {
  
      console.log("点击了div");
  
    })
     
  
  </script>
```



### 57、js精度问题以及解决方案

在JavaScript中尽量避免浮点数直接进行计算，可以将浮点数先转化为整数，之后进行计算

```
   var m=0.1;
   var m2=0.2;
   var m3=m+m2;
   console.log((Math.round(m3*100)/100).toFixed(2));
   先X100 然后 使用Math.round 四舍五入取整，再除以100，最后用toFixed保留两位小数;
   
   第三方数字运算库
    bignumber.js，decimal.js，以及big.js等
    
//官网 https://github.com/MikeMcl/big.js
    
    
big.js 基础用法
运算
 
// 运算
//  const plus = new Big(0.1).plus(0.2); // 加
//  const minus = new Big(0.3).minus(0.1); // 减
//  const mul = new Big(10.22).times(100); // 乘
//  const div = new Big(2.4).div(0.8); // 除
 
let m=0.1;
let n=0.2;
const plus = new Big(m).plus(n); // 加
console.log(plus.toNumber());
  

// toFixed
 
function toFixed(val, len) {
    return new Big(val).toFixed(len);
}


 
```

### 58.foreach如何跳出循环

```
使用  throw Error 抛出异常，使用   try {} catch (error) {}捕获异常
var  arr=[1,2,3,4,5];
try {
arr.forEach((item,index)=>{

    if(index==3){
       throw Error;
    }
    console.log(item);

})
} catch (error) {
    
}

```

### 59、哪些操作会导致内存泄漏

```
1）、意外的全局变量。未被声明的变量，会被挂在window对象下，不能及时的销毁。
2）、定时器setInterval或者setTimeout在不需要使用的时候，没有被清除，导致定时器的回调函数及其内部依赖的变量都不能被回收，这就会造成内存泄漏。
3）、DOM泄漏。
（1）给DOM对象添加的属性是一个对象的引用。解决方法：在window.onload事件中加上 document.getElementById('id').diyProp = null;
（2）元素引用没有清理。var a = document.getElementById('id'); document.body.removeChild(a); 这种操作不能回收，因为存在变量a对它的引用。虽然我们用removeChild移除了，但是还在对象里保存着#的引用，即DOM元素还在内存里面。解决方法：a = null;
（3）事件的绑定没有移除。监听事件没有移除。
4）、js闭包。 闭包过多很容易导致内存泄漏。
5）、 console日志记录。记录错误的对象，可以将大量的数据保留在内存中。传递给console.log的对象是不能被垃圾回收，所以没有去掉console.log可能会存在内存泄漏~
```

### 60、对象循环引用

```
1、对象循环引用的概念
 
循环引用是指两个或多个对象相互引用，形成一个闭环。例如，对象A引用了对象B，而对象B又引用了对象A。这种循环引用会导致内存泄漏，因为垃圾收集器无法正确回收循环引用的对象。

const obj1 = {
  name: 'obj1',
  next: null
};

const obj2 = {
  name: 'obj2',
  next: null
};

obj1.next = obj2;
obj2.next = obj1;

console.log(obj1); // 输出：{ name: 'obj1', next: { name: 'obj2', next: [Circular] } }
console.log(obj2); // 输出：{ name: 'obj2', next: { name: 'obj1', next: [Circular] } }


2. 循环引用对性能的影响
循环引用对性能的影响主要体现在以下几个方面：

内存泄漏：循环引用会导致内存泄漏，因为垃圾收集器无法回收循环引用的对象；
性能问题：循环引用会增加内存使用，导致应用程序的性能下降；
调试困难：循环引用使得调试变得更加困难，因为它们隐藏在对象之间的引用关系中。

3. 解决循环引用的策略

在不再需要循环引用的对象时， 清除它们之间的引用

const obj1 = {
  name: 'obj1',
  next: null
};

const obj2 = {
  name: 'obj2',
  next: null
};

obj1.next = obj2;
obj2.next = obj1;


obj1.next = null;
obj2.next = null;

console.log(obj1);  
console.log(obj2); 

 如果对象中存在循环引用的情况也无法正确实现深拷贝；
let obj3=JSON.parse(JSON.stringify(obj2));   //报错 TypeError: Converting circular structure to JSON

解决：

        var cache = [];
        let obj3 = JSON.stringify(obj2, function (key, value) {
            if (typeof value === 'object' && value !== null) {
                if (cache.indexOf(value) !== -1) {
                    return;
                }
                cache.push(value);
            }
            return value;
        });
        cache = null;    //释放cache

        console.log(obj3);
 

```



## 三、vue

### 1、说说你对MVVM思想的理解

```
MVVM 是一种设计模式，vue，angular等框架就是使用的这种设计思想。MVVM是 Model-View-ViewModel的缩写，即模型-视图-视图模型，
模型（Model）： 数据保存—存放着各种数据，有的是固定写死的，大多数是从后端返回的数据
视图 （View）：用户界面，也就是DOM
视图模型（View-Model）:连接View和Model的桥梁，当数据变化时，ViewModel够监听到数据的变化（通过Data Bindings），自动更新视图，而当用户操作视图，ViewModel也能监听到视图的变化（通过DOM Listeners），然后通知数据做改动，这就实现了数据的双向绑定。
vue就是使用这种编程思想，中心思想就是实现了双向绑定。
```

### 2、数据双向绑定原理

```
大概理解的意思是：

vue2.0:
vue.js 采用数据劫持结合发布-订阅者模式 , 通过Object.defineproperty 来劫持各个属性的setter和getter,在数据变动时发布消息给订阅者,触发相应的监听回调。

Vue2.0 的数组响应式实现主要依赖以下核心机制：Vue 创建了一个继承自原生 Array.prototype 的新对象，并重写了其中 7 个会改变原数组的方法

vue3.0:
有两种方式
ref: 通过Object.defineProperty()的get与set来实现响应式（数据劫持）。(定义基本数据类型)
reactive: 通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect(反射)操作源对象内部的数据. (定义复杂数据类型)

vue2.0双向数据绑定的缺陷: 
1、vue 实例创建后，如果对象再添加属性，不能监听
解决方法：
   this.$set(obj, newkey, newvalue)
2、Object.defineProperty的一个缺陷是通过下标修改数组，无法监听数组变化。

解决方法：
正确修改方式：

1、通过数组的pop(末尾删除)/push(末尾添加)/shift(开头删除)/unshift(开头添加)/reverse(反转)/sort(排序)/splice(起始位置，删除数量，插入元素)方法操作
2、 this.$set(this.arr,下标, '值');
3、通过其他方式（filter/map/...）修改数组，并重新赋值给原数组


//vue2.0双向数据绑定的缺陷: 
<template>
  <div>
    数据双向绑定的缺陷
    <div>{{ userInfo.name }}</div>
    <div>{{ userInfo.age }}</div>
    <div>
      <ul>
        <li v-for="item in list" :key="item.id">
          {{ item.title }}
        </li>
      </ul>
    </div>
    <button @click="update">修改对象</button>
    <button @click="updateList">修改数组</button>
  </div>
</template>
<script>
export default {
  data() {
    return {
      userInfo: { name: "张三" },
      list: [
        { id: 1, title: "北京" },
        { id: 2, title: "上海" },
      ],
    };
  },
  methods: {
    update() {
      // this.userInfo.age=18;//新增的属性 无法监听 页面不更新
      //解决方法
      this.$set(this.userInfo, "age", 18);
    },
    updateList() {
      // this.list[0]={id:1,title:"深圳"}; //通过下标修改数组 无法监听 页面不更新
      //解决方法
      this.$set(this.list, 0, { id: 1, title: "深圳" });
      // this.list=this.list.map((item,index)=>(index!=0 ? item : {id:1,title:"深圳"}));
    },
  },
};
</script>


js实现简单的双向绑定

<body>
    <div id="app">
        <input type="text" id="txt">
        <p id="show"></p>
    </div>
</body>
<script type="text/javascript">
    var obj = {};
    Object.defineProperty(obj, 'txt', {
        get: function () {
            return obj
        },
        set: function (newValue) {
            document.getElementById('txt').value = newValue;
            document.getElementById('show').innerHTML = newValue;
        }
    })
    document.addEventListener('keyup', function (ev) {
        obj.txt = ev.target.value;
    })
</script>


```

```
//Proxy实现数据双向绑定代理
JavaScript 在 ES6 中，引入了一个新的对象类型 Proxy，它可以用来代理另一个对象，并可以在代理过程中拦截、覆盖和定制对象的操作。Proxy 对象封装另一个对象并充当中间人，其提供了一个捕捉器函数，可以在代理对象上拦截所有的操作，包括访问属性、赋值属性、函数调用等等


let proxyObj =new Proxy(obj, {
	// 拦截读取属性值
    get (target, prop) {

        console.log(target,target[prop]);
    	return Reflect.get(target, prop)
    },
    // 拦截设置属性值或添加新属性
    set (target, prop, value) {

        console.log(target, prop,value);

    	return Reflect.set(target, prop, value)


    },
    // 拦截删除属性
    deleteProperty (target, prop) {
    	return Reflect.deleteProperty(target, prop)
    }
})

proxyObj.name="张三";
```



### **2.2 vue数据响应式原理 - 数组的响应式**

```
vue 改写了数组的七个方法：push、pop、shift、unshift、splice、sort、reverse。使数组改变的时候能够触发响应式，先把原来的 Array.prototype 的方法备份一份，再进行重写。

https://www.cnblogs.com/buluzombie/p/15204087.html
```



 **Object.defineProperty是用于监听属性，而Proxy是监听整个对象** 



### 3、vue内置指令有那些    v-if和v-show的区别

```
Vue的指令有：
	v-show（显示隐藏）、v-bind（绑定属性 简写：）、v-if（条件判断）、v-on（事件监听简写@）、
	v-text（渲染文本）、v-for（循环）、v-html（渲染文本和标签）、v-model（表单控件，双向绑定）、
	
	v-once（只渲染一次）、v-slot（插槽简写#）、v-cloak（防闪烁）、v-pre（预编译）
	
v-if和v-show都是vue内置的指令，都可以控制元素的显示与隐藏。

区别：
	v-if是通过判断条件重建与销毁DOM元素来控制元素的显示隐藏。
	v-show是通过CSS的display来控制元素的显示与隐藏。
	v-if频繁切换消耗高，v-show初始渲染消耗高。
使用场景：
	所以需要频繁切换状态时，使用 v-show
	要加快初始化时的渲染速度（组件的重建和销毁时），使用 v-if
```

### 4、key的作用

```
第一种答法
key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度，key具有唯一性。
让每一个元素有一个唯一的识别身份，主要是为了vue精准的追踪到每一个元素，更高效的更新虚拟DOM。

专业回答：
	1.key的作用主要是为了高效的更新虚拟DOM,其原理是vue在patch(打补丁)过程中通过key可以精确判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个patch过程更加高效，减少DOM操作量，提高性能。
	2.另外，若不设置key还可能在列表更新时引发一些隐蔽的bug
	3.vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为让vue可以区分他们，否则vue只会替换其内部属性而不会触发过渡效果。
	

第二种答法：
1、key的作用是为了更高效的更新虚拟DOM；
2、vue在patch过程中判断两个节点是否相同key是一个必要条件，渲染一组列表时，key往往是唯一标识，所以如果不定义key的话，vue只能认为比较的两个节点是同一个，哪怕它们实际上不是，这导致了频繁更新元素，使得整个patch过程比较低效，影响性能；
3、实际使用中在渲染一组列表时key必须设置，而且必须是唯一标识，应该避免使用数组索引作为key，这可能导致一些隐蔽的bug；vue中在使用相同标签元素过渡切换时，也会使用key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果；
4、从源码中可以知道，vue判断两个节点是否相同时主要判断两者的key和元素类型等，因此如果不设置key，它的值就是undefined，则可能永远认为这是两个相同节点，只能去做更新操作，这造成了大量的dom更新操作，明显是不可取的。
```

### 5、虚拟DOM

https://www.cnblogs.com/gaosong-shuhong/p/9253959.html

```
虚拟DOM是什么:用JS对象的形式，表示DOM和DOM之间的嵌套关系.Vue在这个Virtual DOM 上实现了一个 diff 算法，当要重新渲染组件的时候，会通过 diff 寻找到要变更的 DOM 节点，再把这个修改更新到浏览器实际的 DOM 节点上，所以使用虚拟DOM性能会比原生 DOM 快很多。
```

![12](assets/12.png)

![10](assets/10.png)

```
patch函数

patch函数的执行分为两个阶段，两次传递的参数都是两个

第一阶段为虚拟dom的第一次渲染，传递的两个参数分别是放真实DOM的container和生成的vnode，此时patch函数的作用是用来将初次生成的真实DOM结构挂载到指定的container上面。

第二阶段传递的两个参数分别为vnode和newVnode，此时patch函数的作用是使用diff算法对比两个参数的差异，进而更新参数变化的DOM节点；

可以发发现h函数和patch函数在cnabbdom中实现vdom到真实DOM的转化起到了至关重要的作用，那么还有一个很重要的环节，patch函数中是怎么样实现对比两个vnode从而实现对真实DOM的更新的呢，这里还要提一下snabbdom的另外一个核心算法，即diff算法。
```

### 6、diff算法

```
1.diff 算法是虚拟dom生成的必然产物，通过新旧虚拟dom比较，将变化的地方更新到真实的dom上
2.当页面的数据发上变化的时候，Diff算法只会比较同一层级的节点
3.在diff算法时key的作用很重要，就是为了高效的更新虚拟DOM
```

### 7、watch和computed的区别

```
区别：
	1、computed有缓存，watch没有缓存。
	2、computed调用时不需要加括号，watch不需要调用。
	3、当属性没有发生改变时computed会从缓存中读取值，watch当属性发生改变时会接收到两个值，一个新值、一个旧值。
	4、computed中的函数名可以随意命名，watch中的函数名必须时data中的属性名。
	5、computed必须有返回值。
如果watch需要监听对象，必须设置深度监听。（deep = true）

应用场景：
	a）多个数据变化影响一个数据的变化，使用computed。监听数据变化时候用computed
	b）一个数据变化影响多个数据变化，使用watch。增加业务逻辑用watch
	
	
	watcheffect（（）=>{
	
	  
	}）
```

### 8、vue自定义指令

```
在 Vue，除了内置的指令 ( v-model 和 v-show,v-if,v-for等 )，Vue 也允许注册自定义指令。它的作用价值在于当开发人员在某些场景下需要对普通 DOM 元素进行操作

自定义指令：全局自定义指令
		  局部自定义指令
1、可以使用Vue.directive( dir_name , {} ) 来定义全局自定义指令
2、也可以使用 directives{ dir_name : {} } 来定义局部自定义指令
钩子函数 : 
    bind 
        只调用一次, 当指令第一次绑定在元素上时.
        用来做一次性初始化操作.
    inserted
        当绑定元素已插入到父节点时调用.
        也就是说 必定存在父节点.
        但是 它及它的父节点 未必存在文档中.
    update
        在包含该组件的VNode更新后调用该函数.
        可能在其子级更新前调用.
        指令的值可能已更改,可能未更改.最好通过判断新旧值来过滤掉不必要的操作.
基本语法
全局定义指令
 Vue.directive('xxx-xxx' , function( el , binding ) {
            el.style.backgroundColor = binding.value ;
        })
局部定义指令
directives:{   //自定义私有指令
             'fontweight':{
                  bind(el,binding){
                     el.style.fontWeight = binding.value;
                  },
              },
              'color-swatch'(el, binding) {   //简写
                    el.style.backgroundColor = binding.value;
               }
         }
```

### 9、说说你对生命周期的理解

```

生命周期钩子函数：在这个生命周期过程中，vue为我们提供了8个常用的钩子函数。

生命周期：
	总共分为8个阶段，创建前/后，载入前/后，更新前/后，销毁前/后。
	
	三个阶段、四个事件、8个钩子函数；
	
	
共三个阶段：
 1、创建阶段
beforeCreate：
	阶段，vue实例的挂载元素$el和数据对象data都为undefined，data和methods还未初始化。
created：
	阶段，数据对象data和methods已经初始化，但$el还没有，视图和实例还没有挂载。
beforeMount：
	阶段，vue实例的$el和数据对象data都已经初始化，但还是虚拟的dom节点，视图和实例还没有挂载。
mounted：
	阶段，模板已经编译好，虚拟dom渲染成真正的dom标签，数据已经渲染到页面，Vue实例已经创建完毕。
	
	2、运行阶段
beforeUpdate：
	阶段当数据依赖改变时，对象data中的 数据已经更改（虚拟dom已经重新渲 染），但是还未开始渲染真正dom，页面中的值还是原来的。
updated：
	阶段data中的数据更新完毕，页面已经被重新渲染。
	3、销毁阶段
beforeDestroy：
	阶段实例还是可用的一般在这里做一些清除副作用工作。（例如清除定时器、清除非指令绑定的事件等等。）。
destroyed：
	阶段Vue实例被销毁，观察者、子组件、事件监听被清除（页面数据不会消失，只是响应式无效了）。
	
一般会在created阶段做网络请求,在mounted阶段对第三方插件的初始化。
在destroyed阶段进行清除定时器和一些事件的解绑

vue3.0

- Vue3.0的生命周期相对于vue2.0做了以下 调整 ：
 beforeCreate`===>`setup()`
  created`=======>`setup()`
   beforeDestroy```改名为 ```beforeUnmount```
  destroyed```改名为 ```unmounted```
 
 Vue3.0也提供了 Composition API 形式（前面加了on）的生命周期钩子，与Vue2.x中钩子对应关系如下：

- `beforeCreate`===>`setup()`
- `created`=======>`setup()`
- `beforeMount` ===>`onBeforeMount`
- `mounted`=======>`onMounted`
- `beforeUpdate`===>`onBeforeUpdate`
- `updated` =======>`onUpdated`
- `beforeUnmount` ==>`onBeforeUnmount`
- `unmounted` =====>`onUnmounted`
 
```

### 10、实现网络请求的方式及跨域问题的解决方案

```
网络请求的方式：
	1、原生ajax
	2、jq中的ajax
	3、es6中的fetch
	4、vue项目及react项目中使用axios.js
	5、jsonp  但是jsonp只能实现get请求
	6、vue1.0中使用vue-resource.js

跨域分为：前端跨域、后端跨域、线上跨域、线下跨域
解决跨域有多种方法：
	1、使用vue项目中的webpack配置proxy反向代理。
	2、使用nginx反向代理。
	3、使用jsonp。
	4、后台添加代码。
		A） header('Access-Control-Allow-Origin:*');//允许所有来源访问 
		B） header('Access-Control-Allow-Method:POST,GET');//允许访问的方式
线上跨域：
	后台解决。
	
	项目开发阶段一般是在webpack配置proxy反向代理。项目上线之后一般后端解决。
```

### 11、组件之间传值

```
我们做项目vue,react都是组件化开发，那么组件之间有通信，组件传值有以下几种方式

父传子：
	1、父组件发送的形式是用v-bind绑定值到子组件身上。然后子组件用属性props接收。
	2、父组件可以通过ref直接给子组件赋值

子传父：

	1、子组件使用$emit(事件名,需要发送的值)触发自定义事件，父组件使用v-on监听（@事件名=获取值的方法）。
	2、可以使用传方法的方式,父组件给子组件传递一个方法，子组件调用这个方法，通过参数的方式传值（类似react）
	
兄弟：

	A）、两个都要引入公共js->bus。首先是发送者，bus.$emit(名字，值)。然后是接受者,bus.$on("传过来的那个名字"，函数（值）)，这里要注意的是接受者的这个监听事件应该是放在钩子mounted事件内。同时注意this指向问题。（可用封装方法）
	
	
隔代组件(爷孙传值)：

   provide/inject(vue2.5以后)   vuex、pinia都可以实现
	
其它复杂的组件传值：vuex、pinia都可以实现
```

### 12、你都封装过什么组件

```
组件的分类：功能性组件、内容性组件、页面组件
功能性组件：图片轮播、tabbar、tab切换、loading、分页效果等。
页面组件：首页、我的、购物车等
内容性组件：商品列表、商品详情等
```

### 13、什么是路由

```
.后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源，这个对应关系就是后端中的路由；

	因为现在都是前后端分离，所以我们使用的是前端主流的框架，vue框架，vue是单页面应用，为了访问不同的页面和不同的组件，所以需要用路由来进行跳转页面
	
	前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；
	
优点：
	1、用户体验好与后台网速没有关系，不需要每次都从服务器全部获取数据，就能快速展现给客户。
	2、可以在浏览器中输入指定想要访问的url地址。
	3、实现前后端分离，方便开发。有很多框架都带有路由功能模块。
缺点：
	1、使用浏览器前进后退按钮时，会重新发送请求。
	2、单页面应用中在使用前进后退时无法记住滚动位置。
	

后端路由：
	对于普通的网站，所有的超链接都是url地址，所有url都对应服务器上对应的资源。
	浏览器在地址栏中切换不同的url时，每次都向后台服务器发出请求，服务器响应请求，在后台拼接html文件传给前端显示, 返回不同的页面,
意味着浏览器会刷新页面，网速慢的话说不定屏幕全白再有新内容。后端路由的另外一个极大的问题就是 前后端不分离。
优点：
　　　　分担了前端的压力，html和数据的拼接都是由服务器完成。     
缺点：
　　　　当项目十分庞大时，加大了服务器端的压力，同时在浏览器端不能输入制定的url路径进行指定模块的访问。另外一个就是如果当前网速过慢，
　　那将会延迟页面的加载，对用户体验不是很友好。
```

### 14、路由传参

```
Params传参和query传参
区别：
1、params通过name传参，query通过path、name传参
2、query相当于get请求，参数会在地址栏显示，而params相当于post请求，参数不会再地址栏显示。
3、用params传参，刷新浏览器参数会被清空，用query，由于参数是用路径传参的所以F5强制刷新也不会被清空。
4、使用这两种方式传参的时候都可通过路由的name进行传参，所以在配置路由的时候需要加个name属性
```

### 15、如何配置路由

```
在我们的项目搭建完成时候会有一个router的文件夹里边有一个index.js文件，在这个文件里进行配置
第一步：引入需要配置路由的组件
第二步：在index.js中有routes数组 在数组里边有对象 每一个对象就是每一条路由（在routes数组添加一个对象）
第三步：在对象内添加path和component。path的值为组件对应的路径，component的值为路径对应的组件。

当然我们也可根据实际情况进行路由属性的添加及使用。
	比如：
		name、meta、beforeEnter、redirect、params、query
```

### 16、$router和$route的区别

```
router为VueRouter的实例，是一个全局路由对象，包含了路由跳转的方法、钩子函数等。
route 是路由信息对象||跳转的路由对象，每一个路由都会有一个route对象，是一个局部对象，包含path,params,hash,query,fullPath,matched,name等路由信息参数。
```

### 17、路由钩子的理解

```
导航钩子： 就是路由的生命周期
分为：全局路由守卫、组件内守卫、路由独享守卫
全局的钩子函数
	beforeEach()  	在路由切换开始时调用 
	使用场景：登录拦截、动态路由
	 
	afterEach()		在路由切换离开时调用
	应用场景：结束页面加载进度条，修改页面浏览器 title
	
路由独享守卫
	beforeEnter
组件的钩子函数
	beforeRouterEnter
	beforeRouterUpdate
	beforeRouterLeave

 项目中一般使用全局路由守卫的中beforeEach，进行登录拦截。
```



### 18、路由模式及区别

```
hash模式
	地址栏 URL 中的 # 符号，hash 虽然出现在 URL >中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。但是页面刷新的时候，会向服务器端请求数据。

history模式
	HTML5新增的, 改变URL而不刷新页面，地址栏没有#号，在项目打包的时候如果使用history模式，前端的URL必须和实际向后端发起请求的URL一致，服务器可以使用nginx来配置，否则就会出现404错误

```

### 19、路由组件有那些及如何使选中路由高亮显示

```
router-link  router-view
通过linkActiveClass属性设置类名
```

### 20、对keep-alive的理解

```
keep-alive是Vue的内置组件，当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁
用来缓存组件，避免多次加载相同的组件，减少性能消耗，提高用户体验。

项目中使用：
列表页搜索、分页后修改，修改后如果不使用keep-alive会跳回第一页，搜索条件也没保留，所以使用keep-alive跳回当前页。

不希望组件被重新渲染影响使用体验,  keep-alive生命周期钩子函数activated 和 deactivated,主要用于保留组件状态或避免重新渲染,在组件切换过程中将状态保留在内存中，防止重复渲染DOM，减少加载时间及性能消耗，提高用户体验性.


vue2.0 如何 使用keep-alive？
    <keep-alive>
      <router-view v-if="$route.meta.keepAlive"/>
   </keep-alive>
   <router-view v-if="!$route.meta.keepAlive" />
   
 路由表 router/index.js
     const routes = [
  {
    path: '/',
    name: 'home',
    meta:{keepAlive:true},
    component: HomeView
  },
  {
    path: '/about',
    meta:{keepAlive:false},
    name: 'about',
    component: () => import('../views/AboutView.vue')
  }
]
    
   
vue3.0 如何 使用keep-alive？
 <router-view v-slot="{ Component }">
        <keep-alive>
          <component  :is="Component" />
        </keep-alive>
</router-view>

```

### 21、说说你对vuex的理解

```
vuex的概念：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理所有组件的状态，可以实现数据存储及多组件间的数据共享。
vuex的应用场景：存储用户登录信息（token,权限）、组件嵌套太多，组件数据传递不太方便的时候，可以使用vuex,比如购物车、用户信息等一些共享数据。

五个状态分别是：State、Getters、 Mutations、Actions、Modules。

State：存储状态（数据）。 
getters：可以认为是 store 的计算属性， 加工state成员给外界。
mutations：存储同步函数的，更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。
actions：存储任意异步操作，通过提交 mutation 间接改变状态。
modules：将 store 分割成模块，每个模块都具有state、mutations、actions、getters、甚至是嵌套子模块

vuex的优点
	1.解决了非父子组件的消息传递（将数据存放在state中）
	2.减少了AJAX请求次数，有些情景可以直接从内存中的state获取
vuex的缺点
	1.刷新浏览器，vuex中的state会重新变为初始状态
	解决方案 采用插件(vuex-along ,vuex-persistedstate) 或 使用 sessionStorage 、loaclStorage.
		
		https://github.com/robinvdvleuten/vuex-persistedstate
	得配合计算属性和sessionStorage来实现
	
	
vuex工作的流程：首先通过dispath异步提交到action，action通过commit操作mutation，mutation会修改state中的值，state渲染页面

 
```

### 22、nextTick的作用

```
nextTick：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。
 vue是依靠数据驱动视图更新的，该更新的过程是异步的。
应用场景：
当数据更新了，在dom中渲染后，自动执行该函数

1、如果要在created()钩子函数中进行的DOM操作，由于created()钩子函数中还未对DOM进行任何渲染，所以无法直接操作，需要通过$nextTick()来完成。

Vue生命周期的created()钩子函数进行的DOM操作要放在Vue.nextTick()的回调函数中。

2、更新数据后，想要使用js对新的视图进行操作时
	
3、在使用某个第三方插件时 ，希望在vue生成的某些dom动态发生变化时重新应用该插件，也会用到该方法，这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法。

Vue.nextTick()的回调函数中；
	通俗的理解是：更改数据后想立即使用js操作新的视图的时候需要使用nextTick。
```

### 23、vue组件data为什么要是函数形式而根实例则没有此限制？

```
答：1、Vue组件可能存在多个实例，如果使用对象形式定义data，则会导致它们公用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的；采用函数形式定义，在initData时会将其作为工厂函数返回全新data对象，有效规避多实例之间状态污染问题。
2、而在Vue根实例创建过程中则不存在该限制，也是因为根实例只有一个，不需要担心这种情况


如果 data 是个对象，那么整个vue实例将共享一份数据，也就是各个组件实例间可以随意修改其他组件的任意值，这样对于实际开发时很难受的。

但是 data 定义成一个函数，将会 return 出一个唯一的对象，不会和其他组件共享一个对象。
```

### 24、vue.2.0混入 (Mixin)- vue3.0 自定义hook函数

```
简单来说混入和vuex的使用方式差不多一样，都可以实现数据存储以及数据共享，我来说下它们的区别

vuex：用来做状态管理的，里面定义的变量在每个组件中均可以使用和修改，在任一组件中修改此变量的值之后，其他组件中此变量的值也会随之修改。

混入 (mixin) ： 是一种Vue组件中可复用功能的非常灵活的一种方式。

混入对象（mixins）是一个js对象，

它可以包含我们组件中script项中的任意功能选项，如data、components、created、methods 、computed、watch等等。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。

在每个组件中使用，引入组件中之后，各个变量是相互独立的，值的修改在组件中不会相互影响。

分为全局混入和局部混入
// 定义一个全局的Mixin对象
// myMixins.js
export const myMixins = {
    components:{},
    data() {
        return {
        age: 18,
        }
    },
    mounted() {
        this.getAge()
    },
    methods: {
        getAge() {
        // 打印出来data中age
        console.log(this.age)
        }
    }
    }

 // 需要使用的组件1   使用myMixins.js
<div>
  <el-button @click="age++">增加</el-button>
  <div>{{age}}</div>
  <Son></Son>  
</div>
import { myMixins } from "@/mixins/myMixins.js";
import Son from './son'
export default {
	mixins: [myMixins],
    data() {
        return {}
    }, 
}
// 需要使用的组件Son   使用myMixins.js
<div> {{age}}</div>
  export default {
    mixins: [myMixins],
    data() {
       return {}
    },
  }
```



自定义hook函数

```
- 类似于vue2.x中的mixin。
- 什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。
- 自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。

**Hook**
（1） Hook是用来作什么的？
vue3里面可以自定义hook 主要是用来存储一些复用的逻辑、变量的封装。相当于vue2里面的minins

（2）既然vue2有minins为什么vue3提出了Hook？
minins虽然实现了重复代码的提取，但是minins的缺点就是

（1）组件的data、methods、filters会覆盖mixins里的同名data、methods、filters。

（2）变量不好找，可读性不好，维护起来比较复杂

minins的声明周期调用的比引入他的组件快，即；minins的beforeCreate->组件的beforeCreate->mixins的Create->组件的Create

为了解决这些问题，于是有了Hook:

（1）不同于mixin, hook是函数，这样就可以帮助我们提高代码的复用性, 让我们能在不同的组件中都利用 hooks 函数

例子1：

​```
// userComputed.js
import { reactive, ref } from "vue";
export default function () {
    const num = ref(0)
    const add = () => {
        console.log('增加')
        num.value++
    }
    const subtraction = () => {
        num.value--
    }
    return {
        num,
        add,
        subtraction
    }
}
​```

**vue文件**


<template>
  <div class="navMenu">
    <div style="margin-bottom: 100px">我是导航1的子级1</div>
    <div class="num">数字：{{ num }}</div>
    <div class="btn">
      <el-button @click="add">增加</el-button>
      <el-button @click="subtraction">减少</el-button>
    </div>
  </div>
</template>
<script setup>
  import { reactive } from "vue";
  import userComputed from "@/hooks/userComputed"; // 引入hook的js文件
  const { num, add, subtraction } = userComputed();
</script>
​```


```







### 25、vue中的两个内置组件

```
transition  keep-alive
```

### 26、vue3.0和2.0的区别

```
https://blog.csdn.net/qq_39045645/article/details/106372407
https://blog.csdn.net/qq_42308316/article/details/111035113
2020年9月19日凌晨，尤雨溪大大正式发布了 Vue.js 3.0 版本
vue3.0的新特性

	1、vue3.0新增Composition(组合式) API，更好的代码复用。
	   vue2.0主要使用Options(选项式) API
	  Composition API 是以函数的形式展示组件属性。其中setup 函数是组合式API的入口。
	  
	2、数据双向绑定原理不一样，使用Proxy替换Object.defineProperty实现数据的双向绑定
	
		Vue2.0使用Object.defineProperty
		原理：通过使用 Object.defineProperty 来劫持对象属性的 geter 和 seter 操作，当数据发生改变发出通知订阅者，做响应变化。
		
		Vue 3.0使用ES6的新特性porxy
        有两种方式
        ref(定义基本数据类型): 通过Object.defineProperty()的get与set来实现响应式（数据劫持）。
        reactive: 通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect(反射)操作源对象内部的数据. (定义复杂数据类型)
		 	
	3、生命周期的变化
		- Vue3.0的生命周期相对于vue2.0做了以下 调整 ：
                beforeCreate`===>`setup()`
                created`=======>`setup()`
                beforeDestroy```改名为 ```beforeUnmount```
                destroyed```改名为 ```unmounted```
          Vue3.0也提供了 Composition API 形式（前面加了on）的生命周期钩子
 
	4、filters被移除
	5、vue3.0去除了Mixins 新增了自定义hook函数
	6、新增了wactheffect
	7、 vue2.0  v-for 优先 v-if  vue3.0:  v-if 优先 v-for
	8、 模板根节点  vue2.0只有一个根节点  vue3.0 可以有多个根节点
	9、重构virtual dom
	10、更能兼容 ts
```

```
vue2.x数据双向绑定
 1 <!DOCTYPE html>
 2 <html lang="en">
 3 <head>
 4     <meta charset="UTF-8">
 5     <meta name="yingaxiang" content="width=device-width, initial-scale=1.0">
 6     <title>vue2.x数据双向绑定</title>
 7 </head>
 8 <body>
 9     <div>
10         <input type="text" id="input">
11         <span id="text"></span>
12     </div>
13 </body>
14 </html>
15 <script>
16     var obj = {};
17     Object.defineProperty(obj, 'prop', {
18         get: function () {
19             return val;
20         },
21         set: function (newVal) {
22             val = newVal;
23             document.getElementById('text').innerHTML = val;
24         }
25     });
26     document.addEventListener('keyup', function (e) {
27         obj.prop = e.target.value;
28     });
29 </script>
```

```
 vue3.0数据双向绑定
 1 <!DOCTYPE html>
 2 <html lang="en">
 3 <head>
 4     <meta charset="UTF-8">
 5     <meta name="yingaxiang" content="width=device-width, initial-scale=1.0">
 6     <title>vue3.0数据双向绑定</title>
 7 </head>
 8 <body>
 9     <div>
10         <input type="text" id="input">
11         <span id="text"></span>
12     </div>
13 </body>
14 </html>
15 <script>
16     var obj = {};
17     var obj1 = new Proxy(obj, {
18         // target就是第一个参数obj, receive就是返回的obj(返回的proxy对象)
19         get: function (target, key, receive) {
20             // 返回该属性值
21             return target[key];
22         },
23         set: function (target, key, newVal, receive) {
24             // 执行赋值操作
25             target[key] = newVal;
26             document.getElementById('text').innerHTML = target[key];
27         }
28     })
29     document.addEventListener('keyup', function (e) {
30         obj1[0] = e.target.value;
31     });
32 </script>
```

### 27、图片懒加载原理

```
在图片没有进入可视区域时，先不给<img>的src赋值，这样浏览器就不会发送请求了，等到图片进入可视区域再给src赋值。
vue-lazyload.js
```

### 28、restful API

```
Rest是web服务的一种架构风格，一种设计风格，是一种思想；同时Rest不是针对某一种编程语言的。
restful：遵守了rest风格的web服务，也就是webAPI接口规范，是后台人员编写。


非Rest设计，以往我们都会这么写：

	http://localhost:8080/admin/getUser （查询用户）
	http://localhost:8080/admin/addUser （新增用户）
	http://localhost:8080/admin/updateUser （更新用户）
	http://localhost:8080/admin/deleteUser （删除用户）

Rest架构：

GET 	http://localhost:8080/admin/user （查询用户）
POST 	http://localhost:8080/admin/user （新增用户）
PUT 	http://localhost:8080/admin/user （更新用户）
DELETE 	http://localhost:8080/admin/user （删除用户）

为什么需要Restful
	URL具有很强可读性的，具有自描述性
	规范化请求过程和返回结果
	资源描述与视图的松耦合
	可提供OpenAPI，便于第三方系统集成，提高互操作性
	提供无状态的服务接口，降低复杂度，可提高应用的水平扩展性

method请求方式
	get
	post
	put
	delete
	PATCH(一般不用)
```

### 29、项目优化

![1660215856066](C:\Users\陈耀鑫\AppData\Roaming\Typora\typora-user-images\1660215856066.png)

```
v-for 遍历避免同时使用 v-if
keep-alive缓存页面
细分vuejs组件降低耦合性
使用better-click防止iphone点击延迟
减少网络请求

图片懒加载
路由懒加载
比如我们使用的Element Ui的时候 使用第三方插件按需引入，不是全部引入
使用CND资源
使用骨架屏提高用户体验
开启gzip压缩
减少请求次数。


页面优化：
	1、使用cdn引入。
	2、使用图片懒加载、路由懒加载、组件懒加载。
	3、使用gzip压缩。
	4、减少请求次数。
	5、利用缓存。
	6、使用dns预解析。
	
	1.编码优化:
    1.不要将所有的数据都放在data中，data中的数据都会增加getter和setter，会收集对应的watcher
    2.vue 在 v-for 时给每项元素绑定事件需要用事件代理
    3.SPA页面采用keep-alive缓存组件
    4.拆分组件( 提高复用性、增加代码的可维护性,减少不必要的渲染 )
    5.v-if 当值为false时内部指令不会执行,具有阻断功能，很多情况下使用v-if替代v-show
    6.key保证唯一性 ( 默认vue会采用就地复用策略 )
    7.Object.freeze 冻结数据
    8.合理使用路由懒加载、异步组件
    9.尽量采用runtime运行时版本
    10.数据持久化的问题 （防抖、节流）

2.Vue加载性能优化:
    第三方模块按需导入 (babel-plugin-component)
    滚动到可视区域动态加载 ( https://tangbc.github.io/vue-virtual-scroll-list )
    图片懒加载 (https://github.com/hilongjw/vue-lazyload.git)

3.用户体验:
    app-skeleton骨架屏  loading等
    app-shellapp壳   就是app的壳，先渲染app的头部和导航 
    pwa  实现H5的离线缓存  serviceworker
4.SEO优化：
    预渲染插件 prerender-spa-plugin
    服务端渲染ssr
5.打包优化:
    使用cdn的方式加载第三方模块
    多线程打包 happypack
    splitChunks 抽离公共文件
    sourceMap生成
6.缓存，压缩
    客户端缓存、服务端缓存
    服务端gzip压缩
```

### 30、vue和react的区别

```
Vue和React的共同点
	01. react采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定
	02. 两者都需要编译后使用
	03. 中心思想相同：一切都是组件，组件实例之间可以嵌套
	04. 都提供合理的钩子函数，可以让开发者定制化地去处理需求
	05. 都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载

Vue和React的不同点
	01. Vue性能更好、Vue性能上更有优势，因为 Vue 的 Virtual DOM 实现相对更为轻量一些，整体大小		           比react.js更小更轻便
	02. react.JS 彩用SX语法，对语大部分工程师入手比较困难，需要要大量的时间去学习适应这种新语法的			     形式，vue采用DOM模板的方法，易看易用
	
```

React和Vue的区别
**1.监听数据变化的实现原理不同**
Vue通过getter/setter方法以及一些函数的劫持能精确知道数据的变化。

React默认是通过比较引用方式diff算法进行的，若不优化，会导致大量不必要的VDom的重新渲染。

2.数据流不同
Vue实现双向绑定：props可以双响绑定，组件与Dom之间可以通过v-moudel绑定。

React不支持双向绑定：提倡单向数据流，称之为onChange/setState模式。

3.组件通信的区别
Vue中有三种方式可以实现组件通信：

a. 父组件通过props向子组件传递数据或者回调，虽然可以传递回调，但是一般只传递数据；

b. 子组件通过事件向父组件发送消息；

c. 通过Vue2.2中新增的provide/inject来实现父组件向子组件注入数据，可以跨越多个层级。

React中有三种方式实现组件通信：

a. 父组件通过props向子组件传递数据或者回调；

b. 可以通过context进行跨层级的通信；

c. React本身不支持自定义事件，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数。

4.模板渲染方式不同
在表层上，模板的语法不同。React是通过jsx来渲染模板，Vue是通过一种拓展的html语法来进行渲染，但其实这只是表面现象，毕竟React并不必依赖jsx.

在深层上，模板的原理不同。本质的区别在于：React是在组件js代码中，通过原生js实现模板汇总的常见语法，比如插值、条件、循环等，都是通过js语法实现，更加纯粹、原生；而Vue是在和组件js代码分离的单独模板中，通过指令来实现的，比如条件语句v-if。

】5.模板渲染过程不同
Vue可以更快的计算出Virtual Dom的差异，这是由于它在渲染过程中，会跟踪每个组件的依赖关系，不需要更新渲染整个组件树。

React在应用的状态被改变时，全部子组件都会重新渲染。通过shouldComponentUpdate这个生命周期函数可以进行控制，但Vue将次视为默认的优化。

如果应用中交互复杂，需要处理大量的UI变化，那么使用Virtual Dom是一个好主意，如果更新不频繁，可以直接操控DOM。

6.框架本质不同
Vue本职是MVVM框架，有MVC发展而来。

React是前端组件框架，有都断组件演化而来。


### 31、什么是token（说说你对token的理解）

```
用于做用户的唯一身份的识别。
1、Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。

2、Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。

3、使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。

https://blog.csdn.net/qq_38129062/article/details/89350244
```

### 32、vueX数据是临时存储的

```
https://www.cnblogs.com/wang-sai-sai/p/11076833.html
```

### 33、v-for和v-if的优先级? (能在一行写吗？如果不能？怎么解决？)

```
答：v-for优先级大于v-if
不能写在一行，
解决办法:可以加template写v-for 下边的div写v-if
```

### 34、api接口请求一般放在那个生命周期函数中？

```
答：我们在做项目的时候，一般放在create生命周期函数中，但是要操作dom的话放在create里不支持，这时候需要放在mounted中
```

### 35、vue组件从创建开始到创建结束经历了哪几个生命周期函数？

```
答：从开始到创建一共经历了四个生命周期
1、beforeCreate
2、created
3、beforeMount
4、mounted
```

### 36、页面中有父子组件，组件创建时生命周期顺序如何执行？

```
1、父创建前beforeCreate
2、父创建之后created
3、父挂载之前beforeMount

4、子创建前beforeCreate
5、子创建之后created
6、子挂载之前beforeMount
7、子挂载之后mounted

8、父挂载之后mounted
```

### 37、子组件销毁过程生命周期

```
1、父更新之前beforeUpdate

2、子销毁之前beforeDestroy
3、子销毁之后destroyed


4、父更新之后updated
```



### 37.2 页面中有父子组件，父组件销毁时生命周期顺序如何执行？

```
父组件beforeDestroy

子组件beforeDestroy
子组件destroyed

父组件destroyed
```



### 38、vue.js的两个核心

```
1、数据驱动
2、组件化
```

### 39、动态路由

```
动态路由只要是依于vue-router实例router提供的addRoute函数,可以让我们在[路由表中]|(路由配置中),动态添加路由对象的能力,从而达到动态路由的目的.

一般用于作为权限管理的页面访问控制时候使用.

页面访问控制：

1、路由配置静态  >  用户登录 > 返回权限  >  路由守卫 进行拦截

2、通过动态路由实现页面访问控制：
 
用户登录 >  返回页面 >   addRoute函数 > 添加到路由表  

用户登录成功之后，后台会给我们返回该角色对应的权限以及对应的路径，这时候我们可以直接通过addRote函数把该角色的路径循环追加到我们的路由表中，但是这时候我们发现一个问题，就是页面一刷新数据就会丢失，所以我们选择登录成功之后把数据存放到本地缓存中，然后在我们的路由文件中，在beforeEach的钩子里面把我们存入缓存的数据取出来，然后再通过addRote循环追加到我们的路由表中。这就实现了动态路由
```

### 40、vue单页面的优缺点？

```
Vue单页面应用及其优缺点
缺点：

不支持低版本的浏览器，最低支持到IE9。
不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）。
第一次加载首页耗时相对长一些。
不可以使用浏览器导航的前进和后退按钮

优点：

无刷新体验，提升了用户体验。
前端开发不再以页面为单位，更多地采用组件化的思想，代码结构和组织方法更加规范化，便于修改和调整。
API共享，同一套后端程序代码不用修改就可以用于Web页面、手机、平板等多种客户端。
用户体验好、快，内容的改变不需要重新加载整个页面。

vue优点？
答：双向数据绑定，组件化，轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；
简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；
双向数据绑定：保留了angular的特点，在数据操作方面更为简单；
组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；
视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；
虚拟DOM：dom操作是非常耗费性能的， 不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；
运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势
```

### 41、vue中除了v-model还有其他的可以实现数据双向绑定嘛

```
1、input框的话可以使用 @input事件 输出e.target.value
2、单选框的话可以使用@change事件  也是输出e.target.value
```

### 42.介绍一下pinia

```
 Pinia和Vuex一样都是是vue的全局状态管理器 。

 Pinia的概念： Pinia和Vuex一样都是是vue的全局状态管理器 ，可以实现数据存储及多组件间的数据共享。
Pinia的应用场景：存储用户登录信息（token,权限）、组件嵌套太多，组件数据传递不太方便的时候，可以使用pinia,比如购物车、用户信息等一些共享数据。

有三个核心内容：state getters actions

State：存储状态（数据）。 
getters：可以认为是 store 的计算属性， 加工state成员给外界。
actions：修改状态的方法。

```



### 43.vuex与pinia的区别

```
.pinia和vuex的区别

 （1）pinia它没有mutation,他只有state，getters，action【同步、异步】使用他来修改state数据
 （2）pinia他默认也是存入内存中，如果需要使用本地存储，在配置上比vuex麻烦一点

 （3）pinia语法上比vuex更容易理解和使用，灵活。
 （4）pinia没有modules配置，没一个独立的仓库都是definStore生成出来的

 （5）pinia state是一个对象返回一个对象和组件的data是一样的语法
```

### 44.如何自定义 v-model

https://blog.51cto.com/u_15715491/11178850

### 45.如何封装axios请求



### 46、 Axios 如何取消请求 



### 47、token过期问题怎么解决



### 48、如何覆盖elementui样式



### 49、 ElementUI树形控件数据量大时 , 如何解决遇到性能问题

### 50.  vue项目如何性能优化

## 四、React

### 1、React 中 keys 的作用是什么？

Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。

 

```
render () {
 return (
  <ul>
   {this.state.todoItems.map(({item, key}) => {
          return <li key={key}>{item}</li>

   })}
  </ul>
 )
}
```

在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。

### **2、React 加入 Hooks 的意义是什么？为什么 React 要加入Hooks 这一特性？**

为了解决一些component问题：

 

组件之间的逻辑状态难以复用

大型复杂的组件很难拆分

Class语法的使用不友好、

Hooks 就是让你不必写class组件就可以用state和其他的React特性；

 

更容易复用代码：它通过自定义hooks来复用状态，从而解决了类组件逻辑难以复用的问题

函数式编程风格：函数式组件、状态保存在运行环境、每个功能都包裹在函数中，整体风格更清爽、优雅

代码量少，复用性高

 

### **3、if else条件判断里使用hooks有什么问题**

if else里面不能用hooks，hooks是有顺序的

不能用在if else 或者循环里面 还有非顶层的函数内部



 

### **4、常用的Hooks有哪些？**

***\*useState()\****状态钩子。为函数组建提供内部状态

 

***\*useContext()\****共享钩子。该钩子的作用是，在组件之间共享状态。 可以解决react逐层通过Porps传递数据，它接受React.createContext()的返回结果作为参数，使用useContext将不再需要Provider 和 Consumer

 

***\*useReducer()\****状态钩子。Action 钩子。useReducer() 提供了状态管理，其基本原理是通过用户在页面中发起action, 从而通过reducer方法来改变state, 从而实现页面和状态的通信。使用很像redux

 

***\*useEffect()\****副作用钩子。它接收两个参数， 第一个是进行的异步操作， 第二个是数组，用来给出Effect的依赖项

 

***\*useRef()\****获取组件的实例；渲染周期之间共享数据的存储(state不能存储跨渲染周期的数据，因为state的保存会触发组件重渲染）,useRef传入一个参数initValue，并创建一个对象{ current: initValue }给函数组件使用，在整个生命周期中该对象保持不变

 

***\*useMemo\*******\*和useCallback\****可缓存函数的引用或值，useMemo缓存数据，useCallback缓存函数，两者是Hooks的常见优化策略，useCallback(fn,deps)相当于useMemo(()=>fn,deps),经常用在下面两种场景:

1、要保持引用相等；对于组件内部用到的 object、array、函数等，

2、用在了其他 Hook 的依赖数组中，或者作为 props 传递给了下游组件，应该使用 useMemo/useCallback）

 

### **5、useEffect为什么有时候会出现无限重复请求的问题**

可能1 在effect里做数据请求未设置依赖参数，没有依赖项effect 会在每次渲染后执行一次，然后在 effect 中更新了状态引起渲染并再次触发 effect

可能2 所设置的依赖项总是会变

解决：加依赖， useCallback包一层，或者useMemo

 

### **6、React Hooks如何模拟组件生命周期？**

Hooks模拟constructo

//hooks

useEffect(()=>{

 return ()=>{console.log('will unmount')}

},[])

//挂载生命周期函数：useEffect第二个参数如果是一个空数组

//更新生命周期函数：没有第二个参数，或者数组里有依赖

//销毁生命周期函数：useEffect的第一个参数 返回一个匿名函数

 

### **7、useState和setState区别？**

//setState

this.setState(

​	{count:this.state.count+1},

​	()=>{

​	console.log(this.state.count) //通过回调函数监听到最新的值

})

 

//useState

const[count,setCount]=useState(0)

setCount(1)

useEffect(()=>{

 console.log(count) //通过useEffect监听最新的值

},

[count])

1、setState是通过回调函数来获取更新的state，useState是通过useEffect() 来获取最新的 state

2、二者第一个参数都可以传入函数

3、setState()可以在第2个参数传入回调，useState()没有第2个参数

4、setState()自动具备浅合并功能，useState()更新引用需要手动浅合并

 

两者参数对比

  setState(updater,[,callback])

​     updater:object/function - 用于更新数据

​     callback:function - 用于获取更新后最新的state值

  useState(initState)

​     const [state ,setState] = useState(initState)

​      state:状态

​      setState(updater): 修改状态的方法

​        updater:object/function - 用于更新数据

​      initState : 状态的初始值  

useState中的第二个参数更新状态和class中的this.setState区别？

useState 通过数组第二个参数 Set 一个新值后，新值会形成一个新的引用，捕获当时渲染闭包里的数据 State

 

setState 是通过 this.state 的读取 state,每次代码执行都会拿到最新的 state 引用

 

### **8、用useState实现state和setState功能？**

//方法一 模拟setState传入updater和callback

const [n1,setN1]=useState<any>(0)

const [n1,setN2]=useState<any>(0)

setN1((num)=>{

 setN2(num+1)

 //返回n1修改后的值

 return num+1

})

//方法二 自定义hooks,配合引入useRef

export const useXState =(initState)=>{

   const [state,setState]=useState(initState)

   let isUpdate=useRef()

   const setXState=(state,cb)=>{

​    setState(prev=>{

​     isUpdate.current=cb

​     return typeof state==='function'?state(prev):state

​    })

   }

}

useEffect(()=>{

 if(isUpdate.current){

   isUpdate.current()

 }

 //useEffect不可以每次渲染组件都执行，因此在每次渲染之后都需要判断其是否值得执行

})

return [state,setXState]

//useRef的特性来作为标识区分是挂载还是更新，当执行setXstate时，会传入和setState一模一样的参数，并且将回调赋值给useRef的current属性，这样在更新完成时，我们手动调用current即可实现更新后的回调这一功能

### **9、useReducer和redux区别？**

useReducer是useState的代替方案，用于state复杂变化

useReducer是单个组件状态管理，组价通讯还需要props

redux是全局的状态管理，多组件共享数据

### **10、Hooks性能优化**

useMemo 缓存数据

useCallback 缓存函数

相当于class组件的SCU和PureComponent

### **11、怎么在高阶组件里面访问组件实例?**

1、属性代理。高阶组件通过包裹的React组件来操作props，更改 props，可以对传递的包裹组件的WrappedComponent的props进行控制

2、通过 refs 获取组件实例



### **12、调用 setState 之后发生了什么？**

在代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。

 

### **react 生命周期函数**

初始化阶段：

 

getDefaultProps:获取实例的默认属性

getInitialState:获取每个实例的初始化状态

componentWillMount：组件即将被装载、渲染到页面上

render:组件在这里生成虚拟的 DOM 节点

componentDidMount:组件真正在被装载之后

运行中状态：

 

componentWillReceiveProps:组件将要接收到属性的时候调用

shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）

componentWillUpdate:组件即将更新不能修改属性和状态

render:组件重新描绘

componentDidUpdate:组件已经更新

销毁阶段：

 

componentWillUnmount:组件即将销毁

### **13、shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）**

shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。

 

参考react 性能优化-sf

 

### **14、为什么虚拟 dom 会提高性能?(必考)**

虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。

 

用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。

 

参考 如何理解虚拟 DOM?-zhihu

 

### **15、react diff 原理（常考，大厂必考）**

把树形结构按照层级分解，只比较同级元素。

给列表结构的每个单元添加唯一的 key 属性，方便比较。

React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）

合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.

选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。

参考：React 的 diff 算法

 

### **16、React 中 refs 的作用是什么？**

Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：



### **17、React 中有三种构建组件的方式**

React.createClass()、ES6 class 和无状态函数。

 

### 18、useState怎么处理成同步？

答：使用 useEffect 

```
 useEffect(()=>{
    console.log(1111111,user.name);

  },[user])
```





### 

### **18、了解 redux 么，说一下 redux 把**

redux介绍：

1. redux是一个专门用于做状态管理的JS库(类似vuex,pinia)。
2. 它可以用在react, angular, vue等项目中, 但基本与react配合使用。
3. 作用: 集中式管理react应用中多个组件共享的状态。

redux的三个核心概念
1. action
2. reducer
3. store

工作流程：

   dispath 通过store 调用 reducer  ，reducer 返回新state,再通过store渲染组件

### **19、redux 有什么缺点**



### **20、为什么会有React Hooks，它解决了哪些问题？**

完善函数组件的能力，函数组件更适合 react 组件

组件逻辑复用，hooks表现更好

class复杂组件变的难以理解，逻辑混乱，不易拆解和测试

例如：同样的逻辑，散落在 DidMount 和 DidUpdate 中，DidMount 和 WillUnMount 中，使用 hooks，同样的逻辑可以分割到一个一个的 useEffect 中

 

### *21、*React Hooks 如何模拟组件的生命周期？**

模拟 componentDidMount 和 componentDidUpdate，useEffect 依赖不写

模拟 componentDidMount，useEffect 依赖 []

模拟 componentDidUpdate，useEffect 无依赖，或者依赖 [a, b]

模拟 componentWillUnMount，useEffect 返回一个函数

Ada

### 22、 useEffect和useLayoutEffect区别？

1、useEffect是render结束后，callback函数执行，但是不会阻断浏览器的渲染，算是某种异步的方式吧。但是class的componentDidMount 和componentDidUpdate是同步的,在render结束后就运行,useEffect在大部分场景下都比class的方式性能更好.

2、useLayoutEffect 当你的useEffect里面的操作需要处理DOM,并且会改变页面的样式,可能会出现出现闪屏问题, 



useLayoutEffect里面的callback函数会在DOM更新完成后立即执行,但是会在浏览器进行任何绘制之前运行完成,阻塞了浏览器的绘制

## 五、git

### 1、git常用命令

​	git clone  地址				克隆项目

​	git status					查看状态

​	git add .						提交到暂存区

​	git commit -m '描述'			提交到分支

​	git push origin xxx			提交远程

​	git pull origin xxx				从远程拉取代码并合并到本地分支

​	git checkout -b xxx				创建分支

​	git checkout  xxx				切换分支					

​	git branch					查看分支

​	git reset --hard '版本号'		回退版本

​	git log						查看日志

​	git reflog					查看所有提交的日志

### 2、git的工作流程（git是怎么工作的）	

```
通过git add将工作区的代码提交到暂存区，通过git commit将暂存区的代码提交到自己的分支，git push提交到远程仓库
```

### 3、git fetch和git pull的区别

```
git pull：相当于是从远程获取最新版本并merge到本地。  git fecth + git merge
git fetch：相当于是从远程获取最新版本到本地，不会自动merge。
```

### 4、git pull 和 git rebase  

```
git pull：获取远程分支，并更新本地分支。
git rebase：合并分支到当前分支，只存在一个。
```

##  六 、小程序面试常见问题

### 1、小程序的优势和劣势有哪些？



优点：

**①容易推广**。在微信中，小程序拥有众多入口，且微信用户基数大，这些都有助于推广小程序；

**②使用便捷。**微信下拉即可打开小程序列表，点击即可使用小程序，不需要额外的安装操作等；

**③体验良好。**小程序不会像H5页面一样经常出现卡顿、延时、加载慢、权限不足等问题；

**④成本更低，**从开发成本到运营推广成本，小程序的花费仅为APP的十分之一。

缺点：

①单个包大小限制为2M，这导致无法开发大型的应用，采用分包最大是20M；

②需要像app一样审核上架，这点相对于H5的发布要麻烦一些；

③处处受微信限制。例如不能直接分享到朋友圈，涉及到积分，或者虚拟交易的时候，小程序也是不允许的。


### 2、微信小程序生命周期

```

应用的生命周期：

onLaunch     小程序初始化完成时触发，全局只触发一次
             应用场景： 自动登录

onShow           小程序启动，或从后台进入前台显示时触发

onHide            小程序从前台进入后台时触发

onError                     小程序发生脚本错误或 API 调用报错时触发

页面的生命周期：

onLoad             监听页面加载   发送请求获取数据

onShow            监听页面显示   请求数据

onReady      监听页面初次渲染完成   获取页面元素

onHide             监听页面隐藏   终止任务

onUnload      监听页面卸载         终止任务

组件中的生命周期：

created         监听页面加载

attached        监听页面显示

ready         监听页面初次渲染完成

moved          监听页面隐藏

detached       监听页面卸载


```

### 3、小程序中如何修改data上的数据？

```
通过this.setData（）
```



### 4、微信小程序中如何进行事件的定义，传参

小程序中使用bind、或catch关键字绑定事件，但小程序中不能在绑定事件的同时为事件处理函数传递参数，可以为组件提供 data-* 自定义属性传参，其中 * 代表的是参数的名字。

```
<button bindtap="tapTap" data-param="{{"事件传参"}}">事件传参</button>
```


接收传递到的参数：

接收传递到的参数：

```
tapTap(e){
  console.log(e.currentTarget.dataset.param)
  // 打印结果为：事件传参
}
 
```

### 5、bindtap和catchtap的区别

```
相同点： 都是绑定事件
不同点： bindtap 不会阻止冒泡，catchtap 可以阻止冒泡。

```

### 6.wxss和css有什么区别

WXSS和CSS类似，不过在CSS的基础上做了一些补充和修改。

```
wxss 背景图片只能引入外链，不能使用本地图片

小程序样式使用 @import 引入 外联样式文件，地址为相对路径。

尺寸单位为rpx , rpx是响应式像素,可以根据屏幕宽度进行自适应

在设计750px情况下，1rpx=1px

```

### 7.小程序如何进行页面的跳转传参以及接收数据



**路由跳转传参可以通过？的方式拼接参数。跳转到指定界面之后，可以在该页面的onLoad方法中的options参数（本身是个对象）拿到路由跳转的参数。**



最常用的两个页面的跳转和传参方式：

wx.navigateTo   保留当前页面，只能打开非tabBar页面。

wx.redirectTo()   和 wx.navigateTo() 一样，都 跳转至非tabBar页面，但会关闭当前页面

wx.switchTab()  用来 跳转至tabBar页面，并关闭其他所有非 tabBar 页面

wx.reLaunch()    也是 跳转至非tabBar页面，并且会关闭其他所有页面

wx.navigateBack()  用来返回上一页面或多级页面，并关闭当前页面。



```
wx.navigateTo({
     url: `/pages/details?id=${xxx}`
});
```


跳转页接收参数：

```
onLoad (options) {
    console.log(options)
    this.setData({
      goodsId:options.id,
      goodsName:options.name
  })
}
```

###  8、提高微信小程序速度的方法

```

组件化方案

精简代码，降低WXML结构和JS代码的复杂性；

合理使用setData调用，减少setData次数和数据量

必要时使用分包优化 
分包：https://blog.csdn.net/weixin_46218456/article/details/128743420
```

### 9、小程序中如何进行本地存储？

```
存储数据
wx.setStorage : 异步
wx.setStorageSync ： 同步

获取数据
wx.getStorage: 异步
wx.getStorageSycn: 同步
```

###  10、小程序中如何进行接口请求？会不会跨域，为什么？

```
wx.request 

不会跨域

因为不是浏览器，没有同源策略
```

### 11、怎么封装小程序的数据请求？

**封装目的**

在微信小程序中，我们通常使用wx.request进行网络请求。为了便于管理和维护，我们可以将数据请求进行封装。

封装的目标：

1. 统一管理基础URL。

2. 统一处理请求头（例如：添加token等）。

3. 统一处理错误（例如：网络错误、服务器错误等）。

4. 支持Promise风格调用，避免回调地狱。

5. 可以方便地添加请求拦截器和响应拦截器（如果需要的话）。
6. 统一管理请求状态码

**如何封装**

创建一个request的JS模块

在这个模块里封装wx.request请求，通过Promise解决异步问题

在发送请求之前可以添加统一的请求头

在响应数据之前可以进行统一的逻辑处理

```
  function request(options) {
 
    // 默认的请求头
  let header = {
    "cookie": wx.getStorageSync("cookie") || "",
    "content-type": "application/x-www-form-urlencoded",
  };
 
 
  return new Promise((reslove, reject) => {
    // 调用接口
    wx.request({
      // 默认的配置
      // 加载传入的配置
      ...options,
      header,
      success(res) {
        // 响应拦截器，所有接口获取数据之前，都会先执行这里
        //  1. 统一的错误处理
        if (res.statusCode != 200) {
          wx.showToast({
            title: '服务器异常，请联系管理员',
          })
        }
        reslove(res)
      },
      fail(err) {
        reject(err)
      }
    })
  })
}
//封装get请求
export function get(url, options = {}) {
  return request({
    url,
    ...options
  })
}
//封装post请求
export function post(url, data, options = {}) {
  return request({
    url,
    data,
    method: "POST",
    ...options
  })
}
```

### 12、微信小程序常见的开放能力API有哪些

```
wx.request   http请求
wx.uploadFile
wx.getNetworkType  获取网络状态
wx.downloadFile  从网络上下载pdf文档
wx.openDocument  下载成功之后进行预览文档
wx.scanCode  扫码能力
wx.getUserInfo   用户头像，昵称
```



### 13、小程序登录流程

```
1.wx.login获取临时登录凭证code

2.发送code给后端，后端通过code，appid，appsecret调用微信接口，返回openid和session-key；

3、发送openid给后端返回token和用户信息

4.前端把后端返回的token缓存起来

wx.login 返回coe  ->  发送请求  -> openid  ->发送请求(传openid) ->token、用户信息
```

![https://img-blog.csdnimg.cn/img_convert/769de1c5ebd743c8acf4f281776df38a.jpeg]()

###  14、小程序 `wx:if` 和 `hidden` 的区别 

```
wx:if :  有更高的切换消耗。
hidden : 有更高的初始渲染消耗。

使用：
频繁切换使用 hidden,  运行时条件变化使用wx: if

```

### 15、介绍微信小程序发布上线流程

**1、在微信公众平台里 填写小程序基本信息 如小程序名称  分类  logo**

2、小程序备案

3、服务器域名配置

​     wx.request

​     socket合法域名 

​     uploadFile合法域名 

​     downloadFile合法域名 



**1.提交代码**

通过微**信开发者工具**提交代码

![](https://img-blog.csdnimg.cn/faa034c20699466d8583e7d55d404885.png)

**2、提交审核**

 进入[微信公众平台](https://mp.weixin.qq.com/)，登录帐号，进入后，在左边导航栏中找到**管理**下面的**版本管理**， 点击，**提交审核** 







![](http://api.90000p.com/estate/upload/2023/11/17/202311171350459457955.png)



**3.提交发布**

 小程序成功完成审后核，此时同样进入微信公众平台，登录帐号，进入后，在左边导航栏中找到“**管理”\**下面是\**版本管理**，点击进入，会在**审核版本**处看到你的版本**审核通过**或者审**核不通过**的情况 

 审核通过后，直接点击发布，就可以了。 

![](https://img-blog.csdnimg.cn/88bd23e1525e496283a7bc20faeb1470.png)

什么情况下审核不通过？

 1、资质     有的 服务类目 需要资质

2、垃圾代码

3、垃圾内容

4、有会员： 有  服务条款  个人隐私政策





### 16、在小程序中如何获取用户信息

```
wx.getUserInfo， wx.getUserProfile 、

头像昵称填写能力：
   <button  class="avatar-wrapper" open-type="chooseAvatar" bind:chooseavatar="onChooseAvatar">
      <image class="avatar" src="{{avatarUrl}}"></image>
    </button>
  <input bind:change="getnickname" type="nickname" class="weui-input" placeholder="请输入昵称"/>
  
    <button open-type="getPhoneNumber" bindgetphonenumber="getPhoneNumber">
    获取手机号
  </button>
```



### 17、小程序支付流程



```
1、在小程序中调用小程序登录API  wx.login，获得参数code,并请求接口获取openid；

2、 发起接口调用，并将订单相关参数一起发送到后台

3、 后台根据订单信息，调用统一下单接口

4、 统一下单接口返回预支付信息，后台获取预支付信息，并进行再次签名，返回支付参数（5个参数和sign）给小程序；

5、小程序获得支付参数，调用api  wx.requestPayment 发起支付请求；

6、用户输入支付密码，支付完成；

7、微信后台向商户后台发出异步通知，同时给小程序回调支付结果；

8。小程序获取支付回调结果，进行支付成功或失败对应的页面跳转

```

```
小程序 发起微信支付
wx.requestPayment({
  timeStamp: '',
  nonceStr: '',
  package: '',
  signType: 'MD5',
  paySign: '',
  success (res) {
  
  },
  fail (res) {
  
  }
})
```

微信小程序支付流程：
登录（wx.login） ->  下订单（调接口）  ->等到订单信息 ->调用微信统一下单接口  ->后端返回5个参数 -> wx.requestPayment ->微信弹出支付窗口 ->输入支付密码 ->回调支付结果给小程序



### 18、微信小程序用户授权有哪些

```
    1、基本信息（头像，昵称，年龄，性别，地区）
    2、收货地址
    3、地理位置
    4、绑定手机号

```

### 19、微信小程序分包

微信小程序分包是一种重要的优化手段，主要用于解决小程序主包体积过大（超过微信规定的 **2MB**）导致无法预览、上传或影响用户启动速度的问题。它将小程序的代码按照功能模块划分成不同的子包，在用户需要时才加载，从而显著提升首次启动速度和用户体验。

**分包的核心价值：**

1. **突破主包大小限制：** 主包限制 2MB，整个小程序所有分包总大小限制为 20MB（部分类目如游戏可达更高）。
2. **提升启动速度：** 用户首次打开小程序时，只需下载主包（包含核心功能和启动页面），无需等待所有功能代码下载完成。
3. **按需加载，优化体验：** 当用户访问分包内的页面时，才触发该分包的下载（异步下载），避免一次性加载所有代码造成的卡顿。
4. **代码组织更清晰：** 将不同功能模块的代码（页面、组件、资源、逻辑）组织到不同的分包中，便于团队协作开发和维护。

**分包类型：**

1. **普通分包：**
   - 最常用的分包类型。
   - 不能独立运行，依赖主包。
   - 主包可以调用分包的页面，分包也可以调用主包的公共资源（需谨慎，最好避免）。
   - 分包之间默认不能互相调用页面和资源。
2. **独立分包：**
   - 可以完全独立于主包运行（不需要下载主包）。
   - 不依赖主包，也不能引用主包的任何资源（包括公共组件、JS 文件、图片等）。
   - **适用场景：** 广告页、活动页、需要快速打开的特定功能页、与主流程关联度低的页面。
   - **优势：** 首次进入独立分包页面时，下载速度更快（只下载该分包），且不受主包更新影响。
   - **配置：** 在分包的 `root` 下配置 `"independent": true`。
   - 

**如何实现分包：**

1. **项目目录结构规划：**

   - 通常在主目录下创建一个专门的文件夹（如 `subpackages` 或 `packages`）来存放所有分包。

   - 每个分包是一个独立的文件夹，包含其自己的页面（`pages`）、组件（`components`）、静态资源（`images`, `assets`）和逻辑（`utils`, `services` 等）。

   - **示例结构：**

     ```
     ├── app.js
     ├── app.json
     ├── app.wxss
     ├── pages/                # 主包页面
     │   ├── index/
     │   ├── logs/
     │   └── ...
     ├── components/           # 主包公共组件 (尽量精简)
     ├── utils/                # 主包公共工具函数
     ├── subpackages/          # 分包根目录
     │   ├── packageA/          # 分包A
     │   │   ├── pages/         # 分包A的页面
     │   │   │   ├── cat/
     │   │   │   └── dog/
     │   │   ├── components/    # 分包A的专用组件
     │   │   └── ...
     │   ├── packageB/          # 分包B (可以是独立分包)
     │   │   ├── pages/
     │   │   │   └── activity/
     │   │   └── ...
     │   └── ...               # 其他分包
     └── ...
     ```

2. **配置 app.json：**
   在 `app.json` 文件中使用 `subpackages` (或 `subPackages`) 字段声明分包信息。

   ```
   {
     "pages": [
       "pages/index/index", // 主包页面
       "pages/logs/logs"    // 主包页面
     ],
     "subpackages": [
       {
         "root": "subpackages/packageA", // 分包根目录
         "name": "shop",                  // 分包别名，可选，用于预下载和跳转
         "pages": [                       // 分包内的页面路径，相对于 root
           "pages/cat/cat",
           "pages/dog/dog"
         ],
         "independent": false             // 是否为独立分包，默认 false (普通分包)
       },
       {
         "root": "subpackages/packageB",
         "name": "activity",
         "pages": [
           "pages/activity/activity"
         ],
         "independent": true             // 独立分包
       }
     ],
     "preloadRule": { ... }, // 分包预下载规则 (见下文)
     // ... 其他配置 (tabBar, window等)
   }
   ```

   - `root`: **必填**。分包源码的根目录。
   - `name`: **可选**。分包别名。在预下载和 `wx.navigateTo` 跳转时可以使用 `__APP__` 或别名来指定分包（如 `wx.navigateTo({ url: 'shop/pages/cat/cat' })` 或 `wx.navigateTo({ url: '/subpackages/packageA/pages/cat/cat' })`）。
   - `pages`: **必填**。数组，列出该分包的所有页面路径。路径**不需要**包含 `root` 部分，**也不能**包含在全局 `pages` 数组中。
   - `independent`: **可选**。是否是独立分包，默认 `false` (普通分包)。

3. **分包预下载：**

   - 为了进一步提升用户体验（特别是从主包页面跳转到分包页面时），可以在用户进入主包某个页面时，在后台**静默预下载**可能用到的分包。
   - 在 `app.json` 的 `preloadRule` 字段中配置。

   ```
"preloadRule": {
     "pages/index/index": { // 进入主包首页时
    "network": "all",    // 网络环境：all(不限), wifi(仅wifi)
       "packages": ["subpackages/packageA"] // 或 ["shop"] (使用 name 别名)
    },
     "subpackages/packageA/pages/cat/cat": { // 进入分包A的cat页面时
    "network": "wifi",
       "packages": ["subpackages/packageB"] // 预下载分包B
    }
   }
   ```
   
   - 配置项：`{ "触发页面的路径": { "network": "条件", "packages": ["分包root或name"] } }`
   - **注意：** 预下载体积上限为 2MB。请谨慎配置，避免一次性预下载过多内容反而影响当前页性能。

**重要注意事项与最佳实践：**

1. **主包最小化：** 主包只放**启动页、TabBar 页面**和**最最核心、所有分包都依赖的公共组件/工具库/资源**。尽量将非必要的页面和资源移到分包中。
2. **资源路径：**
   - 页面、组件、JS 文件中的**相对路径**，相对于当前代码文件所在目录解析。
   - **绝对路径** (`/` 开头) 从项目根目录解析。
   - **强烈建议：** 分包内的页面、组件、资源，使用相对于分包根目录的路径，**避免跨分包或引用主包资源**（尤其对于独立分包是强制要求）。主包资源尽量少，分包资源尽量自包含。
3. **自定义组件：**
   - 主包可以引用主包的自定义组件。
   - 分包可以引用分包内的自定义组件。
   - **普通分包可以引用主包的自定义组件，但强烈不推荐！** 这会导致主包变大，且该组件更新会强制所有用户更新主包。如果组件确实需要共享，考虑将其放在一个非常小的公共分包中，或者复制一份到需要的分包中（权衡重复代码和包体积）。
   - **独立分包绝对不能引用主包或其它分包的组件/资源。**
4. **跳转与传参：**
   - 使用 `wx.navigateTo`, `wx.switchTab` 等 API 跳转时，路径可以是：
     - 主包页面：`/pages/index/index`
     - 普通分包页面：`/分包root/页面路径` (如 `/subpackages/packageA/pages/cat/cat`) 或 `__APP__/分包别名/页面路径` (如 `__APP__/shop/pages/cat/cat`，需配置 `name`)。
   - 传递参数的方式与主包内跳转相同（URL Query）。
5. **独立分包限制：**
   - `App` 仅在主包定义，独立分包中无法使用 `getApp()` 获取全局 App 实例（会返回 `undefined`）。独立分包需要管理自己的状态。
   - 独立分包的 `wx.login`, `wx.request` 等 API 的登录态、`request` 的 `header` 等与主包隔离。
   - 插件在独立分包中的使用方式与主包不同（需在分包内声明）。
6. **调试与监控：**
   - 微信开发者工具会清晰展示主包、各分包的大小。
   - 上传代码时，控制台会输出详细的包体积分析。
   - 利用小程序后台的“性能监控”功能观察用户实际的分包加载情况。

**总结：**

微信小程序分包是优化大型小程序性能和组织结构的**必备技术**。通过合理规划目录结构、在 `app.json` 中正确配置 `subpackages` 和 `preloadRule`，并遵循资源引用和组件使用的规范（尤其是独立分包的限制），可以有效地控制主包体积，提升小程序的启动速度和运行流畅度，给用户带来更好的体验。务必牢记“主包最小化”和“分包资源自包含”的原则。

## 七、uni-app

### 1、Uni-app的底层渲染原理是什么？

```
Uni-app 的底层渲染原理是通过编译器将 Vue 语法的代码转换为不同平台（如微信小程序、H5、App 等）的目标代码，借助各平台的原生渲染引擎实现界面展示，同时通过其跨端抽象层统一 API 和组件逻辑，从而达到一套代码多端编译（微信/支付宝小程序、H5、App等）。
```

### 2、Uni-app的生命周期有哪些？

1. **应用生命周期**

应用从启动到销毁的整个过程，包含以下生命周期函数：

onLaunch：应用初始化完成时触发（仅首次启动触发）。

onShow：应用每次被展示时触发（如从前台切换回应用）。

onHide：应用进入后台时触发。

onError：应用捕获错误时触发。

2. **页面生命周期**

页面从创建到销毁的过程，包含以下生命周期函数：

onLoad：页面加载时触发，参数为上个页面传递的数据。

onShow：页面显示时触发（包括初次加载和从后台切换到前台）。

onReady：页面初次渲染完成后触发。

onHide：页面隐藏时触发。

onUnload：页面卸载时触发（如跳转到其他页面或关闭页面）。

onPullDownRefresh：下拉刷新时触发。

onReachBottom：页面滚动到底部时触发。

3. **组件生命周期**

组件生命周期与 Vue 生命周期一致，主要包括：

beforeCreate：实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前调用。

created：实例创建完成后调用，此时可以访问 data 和 methods。

beforeMount：挂载开始之前调用，模板已编译但未挂载到 DOM 上。

mounted：挂载到实例上后调用，此时可以操作 DOM。

beforeDestroy：实例销毁之前调用。

destroyed：实例销毁后调用，所有绑定和子实例均已销毁。

### 3、Uni-app如何处理不同平台的样式差异？

**1）.使用条件编译**

条件编译允许你在代码中根据不同平台编写不同的逻辑和样式。通过 #ifdef 和 #endif 等指令，可以针对特定平台编写特定的样式或逻辑。

```text
/* 在 style 标签中使用条件编译 */
<style>
/* 公共样式 */
.common-style {
  color: #333;
}

/* 仅在微信小程序中生效的样式 */
/* #ifdef MP-WEIXIN */
.mp-specific-style {
  background-color: #f0f0f0;
}
/* #endif */

/* 仅在 H5 中生效的样式 */
/* #ifdef H5 */
.h5-specific-style {
  background-color: #e0e0e0;
}
/* #endif */

/* 仅在 App 中生效的样式 */
/* #ifdef APP-PLUS */
.app-specific-style {
  background-color: #d0d0d0;
}
/* #endif */
</style>
```

**2）.使用 @media 查询**

虽然 @media 查询在 Uni-app 中的使用场景有限，但在某些情况下仍然可以用于处理不同屏幕尺寸的样式差异。

**3). 使用 uni-app 提供的样式类**

Uni-app 提供了一些内置的样式类，可以帮助你更方便地处理不同平台的样式差异。例如，mp-weixin、h5、app-plus 等类可以直接在 HTML 标签中使用。

```text
<template>
  <view class="common-style mp-weixin:mp-specific-style h5:h5-specific-style app-plus:app-specific-style">
    这是一个示例文本
  </view>
</template>

<style>
.common-style {
  color: #333;
}

.mp-specific-style {
  background-color: #f0f0f0;
}

.h5-specific-style {
  background-color: #e0e0e0;
}

.app-specific-style {
  background-color: #d0d0d0;
}
</style>
```

### 4、Uni-app网络请求

uni-app使用uni.request api进行网络请求

```
uni.request({
    url: 'https://www.example.com/request', //仅为示例，并非真实接口地址。
    data: {
        text: 'uni.request'
    },
    header: {
        'custom-header': 'hello' //自定义请求头信息
    },
    success: (res) => {
        console.log(res.data);
        this.text = 'request success';
    }
});
```

### 5、Uni-app页面跳转

页面跳转

Uni-app 提供了多种页面跳转的方式，包括 



uni.navigateTo 保留当前页面，跳转到应用内的某个页面。可以使用 uni.navigateBack 返回到原页面。

uni.redirectTo  关闭当前页面，跳转到应用内的某个页面。

uni.reLaunch 关闭所有页面，打开到应用内的某个页面。

uni.switchTab  跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。

uni.navigateBack关闭当前页面，返回上一页面或多级页面。

### 6、uniap路由拦截

UniApp 路由拦截方案：

- **使用官方拦截器 `uni.addInterceptor`**
- **封装路由函数**
- **页面生命周期拦截**

**方案 1：使用官方拦截器 `uni.addInterceptor`（推荐）**

这是 UniApp 官方提供的路由拦截方案，支持拦截 `navigateTo`、`redirectTo`、`reLaunch`、`switchTab` 等路由跳转方法。

```
// 在 App.vue 或 main.js 中设置
uni.addInterceptor('navigateTo', {
  // 跳转前拦截
  invoke(args) {
    console.log('准备跳转至:', args.url);
    // 检查登录状态（示例）
    const isLoggedIn = checkLoginStatus();
    
    // 需要登录的页面路径
    const loginRequiredPaths = [
      '/pages/user/profile',
      '/pages/order/list'
    ];
    
    // 判断是否需要拦截
    if (loginRequiredPaths.includes(args.url) && !isLoggedIn) {
      uni.showToast({ title: '请先登录', icon: 'none' });
      uni.redirectTo({ url: '/pages/login/login' });
      return false; // 阻止原跳转
    }
    return true; // 允许跳转
  },
  // 跳转成功后触发
  success() {
    console.log('跳转成功');
  }
});

// 添加其他拦截器（如 switchTab）
uni.addInterceptor('switchTab', {
  invoke(args) {
    // 逻辑同上
  }
});
```

------

**方案 2：封装自定义路由方法**

封装统一的路由跳转函数，在其中加入拦截逻辑：

```
// utils/router.js
export const navigateTo = (url) => {
  if (!checkLogin() && needLogin(url)) {
    uni.redirectTo({ url: '/pages/login/login' });
    return Promise.reject('未登录');
  }
  return uni.navigateTo({ url });
};

export const switchTab = (url) => { ... }; // 类似处理

// 在页面中使用
import { navigateTo } from '@/utils/router';

navigateTo('/pages/user/profile');
```

------

**方案 3：全局页面生命周期拦截（适合页面级拦截）**

在 `App.vue` 的全局监听中处理：

```
// App.vue
export default {
  onShow() {
    const pages = getCurrentPages();
    const currentPage = pages[pages.length - 1];
    const route = currentPage.route;
    
    // 检查需要登录的页面
    if (route.startsWith('/pages/user/') && !checkLogin()) {
      uni.reLaunch({ url: '/pages/login/login' });
    }
  }
}
```

### 7、Uni-app如何实现全局状态管理？

 Vuex  或 pinia  或uni.$on/uni.$emit 方法实现。 

### 8、Uni-app**性能优化方案**

- 页面懒加载（分包+延迟加载）、资源压缩（图片压缩、代码压缩）。
- 页面缓存（使用 keep-alive）、使用 localStorage 或 indexedDB 缓存接口数据。
- 使用 CDN 加速静态资源。
- app打包的时候移除不需要模块



### 9、Uni-app存储管理

存数据：uni.setStorage，读数据uni.getStorage

```
//同步
  uni.setStorageSync('key', 'value');
  
// 异步
uni.setStorage({
  key: 'key',
  data: 'value',
  success: function () {
    console.log('数据存储成功');
  },
  fail: function (err) {
    console.error('数据存储失败', err);
  }
});
```

### 10. 如何接入原生模块？

**解析：**

- 使用 `plus.` API 或封装自定义 Native 插件（如 Android 插件、iOS 插件）。
- 通过 JSBridge 与原生代码通信。
- 使用 HBuilderX 调试 App Native 模块。

### 11. 兼容性问题应对策略？

**解析：**

- 条件编译：根据平台差异使用不同逻辑。
- 动态样式适配（如 rpx 与 px）、组件兼容性封装。
- 针对小程序平台提供独立组件实现或样式覆盖。

### 12. 防止重复提交策略？

**解析：**

- 按钮防抖处理（封装指令 `v-throttle`）。
- 提交按钮禁用状态控制（loading 或 disabled 标记）。
- 请求处理中禁止重复发送。

### 13.支付封装（微信+支付宝）

**解析：**

- 使用策略模式，封装 `pay(type, orderInfo)` 方法。
- 根据平台分别调用 `uni.requestPayment`、小程序支付、App 原生支付。
- 支付回调后处理跳转与状态同步。
  

### 14、离线页面支持？

**解析：**

- 使用 localStorage / indexedDB 缓存页面数据。
- 监听 `uni.onNetworkStatusChange` 判断网络状态。
- 无网时加载缓存，有网时刷新并覆盖缓存。

### 15. Vuex vs Pinia？

**解析：**

- Pinia 更轻量，支持组合式 API，支持模块自动化。
- Vuex 支持较老项目，但语法较复杂。
- 建议新项目优先使用 Pinia，尤其在使用 Composition API 时更友好。

### 16、如何将uni-app项目打包成APP？

**答：**

使用HBuilderX或其他支持uni-app的开发工具，可以通过以下步骤进行打包：

- 在HBuilderX中打开项目。
- 配置项目的manifest.json文件，包括应用名称、图标、权限等。
- 使用HBuilderX的“发行”功能，选择“App-手机”模式。
- 选择目标平台（Android或iOS）。
- 根据提示配置签名文件（Android需要Android证书，iOS需要Apple证书）。
- 点击“发行”按钮，等待打包完成。

### 17、 如何解决uni-app APP打包时遇到的常见问题？

- **资源文件过大问题**：可以使用webpack插件如`compression-webpack-plugin`来压缩资源文件。
- **性能优化**：优化代码结构，使用懒加载，减少DOM操作等。
- **白屏或黑屏问题**：检查manifest.json配置是否正确，特别是启动页和图标设置。
- **签名问题**：确保Android使用正确的keystore文件，iOS使用正确的provisioning profile和certificate。
- **依赖库问题**：确保所有依赖都已正确配置在manifest.json的App模块中。



## 八、webpack

### 1、webpack是什么

```
构建项目的工具，模块化打包机 或者 模块打包工具, 对应到前端开发来说，就是将很多的的 css文件，js文件，图片等“物品”，全都写进一个js文件，而不是在一个html页面通过script,link标签去引入多个静态资源.
```

### 2、webpack的作用

```
1)进行重新加载编译。实际就是将浏览器不认识的语法编译成浏览器认识的语法。比如less
编译成css，ES6 语法 转成 ES5等等。
2)减少io请求。通常我们在请求后，会返回一个html到浏览器。这时，我们如果打开控制台，就会发现在html页面通过script,link等标签引用的静态资源， 浏览器会再次发出请求去获取这些资源。但是webpack的打包，将所有的静态资源都合并好了，减少了io请求。
```

### 3、webpack的五个核心

```
1、entry
	入口（entry）指示webpack以哪个文件作为入口起点开始打包，分析构建内部依赖图。
2、output
	出口（output）指示webpack打包后的资源 bundles 输出到哪里，以及如何命名。

3、loader
	loader让webpack能够去处理那些非JavaScript资源css、img等，将它们处理成webpack能够识别的资源，可以理解成一个翻译过程（webpack自身只能理解js和json）。

4、plugins
	插件（plugins）可用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量等。

5、mode
	模式（mode）指示webpack使用相应模式的配置。
	开发模式（development）：配置比较简单，能让代码本地调试运行的环境。
	生产模式（production）：代码需要不断优化达到性能最好。能让代码优化上线运行的环境。
	都会自动启用一些插件，生产模式使用插件更多

```

### 4、webpack的打包优化

```
一、优化图片
	使用 url-loader 优化， 将小图片转化成base64压缩,防止小图片太多请求次数太多。
二、分离第三方包
	打包后的bundle.js文件夹较大，所以每次加载的时候，请求比较慢，所以有必要在打包时将第三方包分离出来。使用CommonsChunkPlugin 插件进行配置。
三、分离 css 文件并压缩 css 文件
	使用 extract-text-webpack-plugin 插件将css文件分离出来。为了使项目加载时候尽早优先加载css样式，也为了解决js文件体积过大的问题
四、压缩 js 文件
	使用 uglifyjs-webpack-plugin 将js压缩，减少打包后的 vendor.js , bundle.js 等js的文件大小
五、压缩Html
	为了减少打包后的文件体积，使性能更好，效率更高，提高加载速度，打包时有必要进行压缩。
	使用html-webpack-plugin 进行压缩
```

### 5、项目中没有用到过webpack配置相关没有怎么去配置过

```
1、跨域的配置
2、2.0项目使用LESS时的配置，4.0的项目无需配置
```

6、webpack的相关优化

```
图片优化
	https://www.jb51.net/article/161272.htm
	控制图片质量，压缩图片大小；
	配置 <img /> 标签的 srcset 来适应不同的屏幕；
	合成雪碧图，减少图片资源请求数；
	使用占位图。
https://www.cnblogs.com/wangjiachen666/p/11561186.html
2. 提高 Webpack 打包速度
2.1 优化Loader搜索范围
2.2 cache-loader缓存loader处理结果
2.3 使用多线程处理打包
2.4 DllPlugin&DllReferencePlugin
2.5 noParse
2.6 IgnorePlugin
2.7 打包文件分析工具
2.8 费时分析
2.9 一些小的优化点
3. 减少 Webpack 打包后的文件体积
3.1 对图片进行压缩和优化
3.2 删除无用的CSS样式
3.3 以CDN方式加载资源
3.4 开启Tree Shaking
3.5 开启Scope Hoisting
3.6 按需加载&动态加载
```



##  九 、ts面试常见问题

### 1、ts优缺点

```
优点：

增强代码的可读性和维护性，在编译的时候就能发现大部分的问题。

类型推导，自动补全，提升开发效率。

静态类型，变量类型可预测

缺点：

1、增加学习成本，需要理解接口和泛型这些。

2、短期增加开发成本，但减少debug和后期维护成本。

3、需要编译，类型检查会增加编译时长，语法和类型系统复杂的话时间特别长。

4、和有些库结合时不是很完美。

5、不是真正的静态类型，可以用 any 类型，也可以进行类型的强制转换。
 
```

### 2、ts数据类型有哪些

```
boolean: 代表 true 或 false。

number: 代表数字，包括整数和浮点数。

string: 代表字符串。

void: 表示没有任何类型，通常用于函数没有返回值的情况。

null 和 undefined: 表示 null 和 undefined 值。

any: 表示任意类型的值，不受类型检查。

never: 表示永远不存在的值的类型，通常用于抛出异常或死循环等场景。

object: 代表非原始类型的值，也就是除 number、string、boolean、symbol、null 或 undefined 以外的类型，比如数组、函数、类等。

Array（数组）：有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []；第二种方式是使用数组泛型，Array<元素类型>

Tuple（元组）：表示一个固定长度的数组类型，其中每个元素的类型可以不同。

Enum（枚举）：表示一组有名字的常量集合，可以为枚举成员指定数值，也可以让TS自动为枚举成员指定数值。

```

### 3、说一下ts的理解，和js的区别

```
TypeScript（简称 TS）是一种开源的编程语言，是 JavaScript 的一个超集，可以编译成纯 JavaScript 代码，由微软开发和维护。

TypeScript 引入了很多面向对象程序设计的特征，包括：

interfaces  接口
classes  类
enumerated types 枚举类型
generics 泛型
modules 模块

主要不同点如下：

TS 是一种面向对象编程语言，而 JS 是一种脚本语言（尽管 JS 是基于对象的）。
TS 支持可选参数， JS 则不支持该特性。
TS 支持静态类型，JS 不支持。
TS 支持接口，JS 不支持接口。
```

### 4、ts泛型

在TypeScript中， 泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，使用时再去指定类型的一种特性。泛型通常用于函数和类中，以处理不同类型的数据。

以下是一个泛型函数的例子：

```
function reverse<T>(arr: T[]): T[] {
  return arr.reverse();
}

let nums = [1, 2, 3, 4];
let reversedNums = reverse<number>(nums);
console.log(reversedNums); // [4, 3, 2, 1]

let names = ["Alice", "Bob", "Charlie"];
let reversedNames = reverse<string>(names);
console.log(reversedNames); // ["Charlie", "Bob", "Alice"]
```

### 5、type和接口interface的区别

type和interface都可以用来定义类型，都可以定义对象和函数；都可以继承或扩展其他类型，但语法不一样；都支持泛型。

不同点：

type可以定义基本类型、联合类型、元组等，也可以定义复杂的类型别名；而interface只能定义对象类型。

type可以使用交叉类型（&）将多个类型合并成一个类型；而interface不支持交叉类，但可以用extends关键词继承。

type的类型别名可以使用typeof获取已有类型的类型，interface不支持这种方式

### 6、any和unknow的区别

 any类型表示任何类型都可以 ；

 unknown类型表示类型未知的值 

区别：当使用any类型时，可以将任何值赋值给该类型，但是当使用unknown类型时，
只有any类型可以被赋值给unknown类型，因为any类型包含了所有类型

不同点：unkonw变量不能赋值给其它变量

```
var num:any=123;
    num='str';
    num=true;
    console.log(num)


var str3:any="你好，世界";
var str4:unknown="hello，world";

var str5:string;
str5=str3;//any类型可以赋值给其它变量
//str5=str4;//报错，unkonw不能赋值给其它变量
 
console.log(str5);
```



### 7、为什么要用 TypeScript 

- TS 在开发时就能给出编译错误， 而 JS 错误则需要在运行时才能暴露。
- 作为强类型语言，你可以明确知道数据的类型。代码可读性极强，几乎每个人都能理解。
- TS 非常流行,很多前端框架如 react、angular、vue都可以集成，谷歌等公司都在用 TS、鸿蒙系统ArkTS都使用ts。

### 8、**TypeScript 和 JavaScript 哪个更好？** 

由于 TS 的先天优势，TS 越来越受欢迎。但是TS 最终不可能取代 JS，因为 JS 是 TS 的核心。

选择 TypeScript 还是 JavaScript 要由开发者自己去做决定。如果你喜欢类型安全的语言，那么推荐你选择 TS。 如果你已经用 JS 好久了，你可以选择走出舒适区学习 TS，也可以选择坚持自己的强项，继续使用 JS。



##  十、项目中的问题

1、你的项目是独立开发还是合作开发及项目搭建

2、最近的项目是负责的那一块，用到了那些技术

3、做项目的时候遇到了那些bug,是怎么解决的？

4、 github保没保留以前写的项目,能不能看

5、曾做的后台管理都用到什么技术，做的是那一模块

4、项目是如何测试的？

5、如果项目上线了反应有bug，你是怎么解决的？

6、项目从无到有的流程

```
1、产品经理根据客户的需求会出需求文档
2、召集所有跟这个项目相关的工作人员进行开会商讨（项目的开发时间及上线时间和预算---前端需要几个人，后端需要几个人）
3、UI一般根据产品经理提出的需求文档绘制一个原型图
4、UI开始出UI图
5、项目经理或组长进行项的分工
6、前端人员需要跟后端人员进行沟通（后端出一个项目的接口文档）
7、前后端分别开发
8、完成之后前后端进行联调（接口能不能跑得通、数据能不能正常显示）
9、测试
10、上线
```

7、前后端如何联调

8、项目中的代码规范你们是怎么做的？

```
用的是eslint语法检查
```

##   十一、人资问题

1、自我介绍

2、现在是在职还是离职，离职时间，离职原因

```
您好 我在上家公司离职是因为
公司项目比较少，对技术提升没什么帮助，现在前端技术更新特别快，始终要把提升自身技术放在第一位，只有技术提高了，才能更好的完成公司分配给的任务。
```

3、期望薪资

4、上家公司的团队组成

```
一个产品经理  一个UI 两个前端 三个后端  一个测试
```

5、上家公司有没有给你上保险

6、你自己的优势有那些

```
自己的技术上的和工作态度上的

为人比较随和、比较乐于助人、能够快速的融入到新的环境，喜欢学习新的知识，也有刻苦钻研业务的精神。什么事情要做就做的很投入。缺点是我需要学会更耐心一点。我的性子比较急，我总要我的工作在保证质量的情况下赶在第一时间完成。我不能容忍工作怠慢。
```

7、加班怎么看，上家公司的薪资构成、离职时的工资是怎么涨

8、你是哪个学校毕业的？学什么专业？有哪些课程？

9、上家公司的情况、主营业务是什么？

10、你住哪？平时怎么通勤？

